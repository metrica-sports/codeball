{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"codeball: data driven tactical and video analysis of soccer games Why codeball? While there are several pieces of code / repositories around that provide different tools and bits of codes to do tactical analysis of individual games, there is no centralized place in which they live. Moreover, most of the analysis done is usually not linked or easy to link with the actual footage of the match. Codeball's objective is to change that by: Building a central repository for different types of data driven tactical analysis methods / tools. Making it easy to link those analyses with a video of the game in different formats. What can you do with it The main types of work / development you can do with codeball are: Work with tracking and event data Codeball creates subclasses of Pandas DataFrames for events and tracking data; and provides you with handy methods to work with the data. Work with or create your own tactical models like Zones so that you can for example do game_dataset.events.into(Zones.OPPONENT_BOX) and it will return a DataFrame only with the events into the opponents box. You can also chain methods, like game_dataset.events.type(\"PASS\").into(Zones.OPPONENT_BOX) and will return only passes into the box. Or for example do game_dataset.tracking.team('FIFATMA').players('field').dimension('x') to get the x coordinate of the field players (no goalkeeper data) for team with id FIFATMA. [Not yet implemented] Easily access tactical tools or methods like computing passes networks, pitch control,EPV models, etc Create Patterns to analyze the game Analyze games based on Patterns. A Pattern is a unit of analysis that looks for moments in the game in which a certain thing happens. That certain thing is defined inside the Pattern, but codeball provides tools to easily create them, configure them and export them in different formats for different platforms. You can create your own patterns, or also use the ones provided with the package and configure them to your liking. Add annotations to the events for Metrica Play Codeball incorporates all the annotations models and API information needed to import events with annotations into Metrica Play. You can add directly from the code any visualization available in Metrica Play (spotlights, rings, future trail, areas, drawings, text, etc) to any event. Example You can use any of the above functionality independently. However they are most powerful when combined. As an example, the below code defines a pattern that will look for all passes into the opponent's box. Moreover to be imported into Metrica Play, it will add an arrow and a 2s pause in the video at the moment of the pass, and will add an arrow to the 2D field indicating start and end position of the pass. class PassesIntoTheBox(Pattern): def __init__( self, game_dataset: GameDataset, name: str, code: str, in_time: int = 0, out_time: int = 0, parameters: dict = None, ): super().__init__( name, code, in_time, out_time, parameters, game_dataset ) def run(self) -> List[PatternEvent]: passes_into_the_box = ( self.game_dataset.events.type(\"PASS\") .into(Zones.OPPONENT_BOX) .result(\"COMPLETE\") ) return [ self.build_pattern_event(event_row) for i, event_row in passes_into_the_box.iterrows() ] def build_pattern_event(self, event_row) -> PatternEvent: pattern_event = self.from_event(event_row) pattern_event.add_arrow(event_row) pattern_event.add_pause(pause_time=2000) return pattern_event The above code produces this output when imported into Metrica Play: Supported Data Providers This package is very much WIP. At the moment it only works based on Metrica Sports Elite datasets. However, it uses Kloppy to read in the data so that in the near future will support data from any provider. Trying it out There are no open source Elite datasets at the moment that work with this package. However if you are interested in testing it out and/or developing your own patterns and/or test them in Metrica Play reach out to bruno@metrica-sports.com or @brunodagnino on Twitter. Install it Installers for the latest released version are available at the Python package index . pip install codeball Contribute While created and maintained by Metrica Sports, it's distributed under an MIT license and it welcomes contributions from members of the community, clubs and other companies. You can find the repository on Github . Also, if you have ideas for patterns we should implement, or methods we should include (e.g. pitch control, EPV, similarity search, etc), let us know! You can create an issue on the repo, or reach out to bruno@metrica-sports.com or @brunodagnino on Twitter. Documentation Check the documentation for a more detailed explanation of this package. Tentative TODO This is a very incomplete list of the things we have in mind, and it will probably change as we get input from the community / users. However it gives you a rough idea of the direction in which we want to go with this project! more Zones (half spaces, thirds, 14, etc) - [done] crete types for players, events, etc to filter the data. more ways to filter event and tracking data (e.g pass length) more patterns (currently 4 in the making) pitch control from game_dataset.pitch_control([frame/s]) , same with EPV. easily query xG, g+, xT, etc for events corner strategy classifier. support for other providers, likely StatsBomb next. export events in xml format methods to easily sync tracking and event from different providers. any suggestions?","title":"Home"},{"location":"#codeball-data-driven-tactical-and-video-analysis-of-soccer-games","text":"","title":"codeball: data driven tactical and video analysis of soccer games"},{"location":"#why-codeball","text":"While there are several pieces of code / repositories around that provide different tools and bits of codes to do tactical analysis of individual games, there is no centralized place in which they live. Moreover, most of the analysis done is usually not linked or easy to link with the actual footage of the match. Codeball's objective is to change that by: Building a central repository for different types of data driven tactical analysis methods / tools. Making it easy to link those analyses with a video of the game in different formats.","title":"Why codeball?"},{"location":"#what-can-you-do-with-it","text":"The main types of work / development you can do with codeball are:","title":"What can you do with it"},{"location":"#work-with-tracking-and-event-data","text":"Codeball creates subclasses of Pandas DataFrames for events and tracking data; and provides you with handy methods to work with the data. Work with or create your own tactical models like Zones so that you can for example do game_dataset.events.into(Zones.OPPONENT_BOX) and it will return a DataFrame only with the events into the opponents box. You can also chain methods, like game_dataset.events.type(\"PASS\").into(Zones.OPPONENT_BOX) and will return only passes into the box. Or for example do game_dataset.tracking.team('FIFATMA').players('field').dimension('x') to get the x coordinate of the field players (no goalkeeper data) for team with id FIFATMA. [Not yet implemented] Easily access tactical tools or methods like computing passes networks, pitch control,EPV models, etc","title":"Work with tracking and event data"},{"location":"#create-patterns-to-analyze-the-game","text":"Analyze games based on Patterns. A Pattern is a unit of analysis that looks for moments in the game in which a certain thing happens. That certain thing is defined inside the Pattern, but codeball provides tools to easily create them, configure them and export them in different formats for different platforms. You can create your own patterns, or also use the ones provided with the package and configure them to your liking.","title":"Create Patterns to analyze the game"},{"location":"#add-annotations-to-the-events-for-metrica-play","text":"Codeball incorporates all the annotations models and API information needed to import events with annotations into Metrica Play. You can add directly from the code any visualization available in Metrica Play (spotlights, rings, future trail, areas, drawings, text, etc) to any event.","title":"Add annotations to the events for Metrica Play"},{"location":"#example","text":"You can use any of the above functionality independently. However they are most powerful when combined. As an example, the below code defines a pattern that will look for all passes into the opponent's box. Moreover to be imported into Metrica Play, it will add an arrow and a 2s pause in the video at the moment of the pass, and will add an arrow to the 2D field indicating start and end position of the pass. class PassesIntoTheBox(Pattern): def __init__( self, game_dataset: GameDataset, name: str, code: str, in_time: int = 0, out_time: int = 0, parameters: dict = None, ): super().__init__( name, code, in_time, out_time, parameters, game_dataset ) def run(self) -> List[PatternEvent]: passes_into_the_box = ( self.game_dataset.events.type(\"PASS\") .into(Zones.OPPONENT_BOX) .result(\"COMPLETE\") ) return [ self.build_pattern_event(event_row) for i, event_row in passes_into_the_box.iterrows() ] def build_pattern_event(self, event_row) -> PatternEvent: pattern_event = self.from_event(event_row) pattern_event.add_arrow(event_row) pattern_event.add_pause(pause_time=2000) return pattern_event The above code produces this output when imported into Metrica Play:","title":"Example"},{"location":"#supported-data-providers","text":"This package is very much WIP. At the moment it only works based on Metrica Sports Elite datasets. However, it uses Kloppy to read in the data so that in the near future will support data from any provider.","title":"Supported Data Providers"},{"location":"#trying-it-out","text":"There are no open source Elite datasets at the moment that work with this package. However if you are interested in testing it out and/or developing your own patterns and/or test them in Metrica Play reach out to bruno@metrica-sports.com or @brunodagnino on Twitter.","title":"Trying it out"},{"location":"#install-it","text":"Installers for the latest released version are available at the Python package index . pip install codeball","title":"Install it"},{"location":"#contribute","text":"While created and maintained by Metrica Sports, it's distributed under an MIT license and it welcomes contributions from members of the community, clubs and other companies. You can find the repository on Github . Also, if you have ideas for patterns we should implement, or methods we should include (e.g. pitch control, EPV, similarity search, etc), let us know! You can create an issue on the repo, or reach out to bruno@metrica-sports.com or @brunodagnino on Twitter.","title":"Contribute"},{"location":"#documentation","text":"Check the documentation for a more detailed explanation of this package.","title":"Documentation"},{"location":"#tentative-todo","text":"This is a very incomplete list of the things we have in mind, and it will probably change as we get input from the community / users. However it gives you a rough idea of the direction in which we want to go with this project! more Zones (half spaces, thirds, 14, etc) - [done] crete types for players, events, etc to filter the data. more ways to filter event and tracking data (e.g pass length) more patterns (currently 4 in the making) pitch control from game_dataset.pitch_control([frame/s]) , same with EPV. easily query xG, g+, xT, etc for events corner strategy classifier. support for other providers, likely StatsBomb next. export events in xml format methods to easily sync tracking and event from different providers. any suggestions?","title":"Tentative TODO"},{"location":"changelog/","text":"Changelog 0.1.1 (2020-10-19) More Zones (before only one was defined) Users can now define their own Areas as well. Methods that use to take only one Zone, now can take several Zones, Areas, or a combination of both. We change the way the Zones enum worked. Now the Areas (before called boxes) are the value of the type. We changes Box, by a new class Area, which has an area type as attribute.","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#011-2020-10-19","text":"More Zones (before only one was defined) Users can now define their own Areas as well. Methods that use to take only one Zone, now can take several Zones, Areas, or a combination of both. We change the way the Zones enum worked. Now the Areas (before called boxes) are the value of the type. We changes Box, by a new class Area, which has an area type as attribute.","title":"0.1.1 (2020-10-19)"},{"location":"codeball-frames/","text":"What's a CodeballFrame? CodeballFrames are subclasses of Pandas DataFrames. They have all the methods of a standard DataFrame, but have additional methods and attributes that make it easier to work, filter, and handle data from the game. The base class is BaseFrame , and the main CodeballFrame classes are TrackingFrame and EventsFrame . An important aspect of CodeballFrame, as it is the case for DataFrames, is that methods can be chained. BaseFrame Attributes / properties All CodeballFrame have 3 attributes: records: this holds the records from the datasets created by Kloppy when reading in the data. This attribute is not passed to the result of any action that modifies the data frame. metadata: this holds the metadata from the datasets created by Kloppy when reading in the data. This attribute is preserved when filtering or modifying the data frame. However is lost if the result is a series. data_type: this indicates what type of data the data frame holds. For example DataType.TRACKING or DataType.EVENT Methods get_team_by_id get_period_by_id get_other_team_id TrackingFrame A CodeballFrame that holds tracking data. Methods team() : TrackingFrame.team(team_id) will return a TrackingFrame only containing the columns that have data for team with id team_id. dimension() : TrackingFrame.dimension('x') will return a TrackingFrame only containing the columns with data on the x axis. players() : TrackingFrame.players('field') will return a TrackingFrame only containing the columns with data for the field players (excluding goalkeeper). TrackingFrame.players() will return a TrackingFrame containing the data for all players but drop all the other columns. phase() : TrackingFrame.phase(defending_team=team_id) will return a Series with True on the frames the team with id team_id was defending and False otherwise. stretched() : TrackingFrame.stretched(50) will return a Series with True on the frames the stretched of the values in the columns of the TrackingFrame is higher than the threshold. Since all these methods can be chained, is you want to get the x coordinates of field players for team with id team_id , you can do: TrackingDataFrame.team(team_id).players(field).dimension('x') EventsFrame A CodeballFrame that holds event data. Methods type() : This allows to filter by the type column. EventsFrame.type('PASS') will return a EventsFrame only containing the rows that correspond to PASS type events. result() : This allows to filter by the result column. EventsFrame.result('COMPLETE') will return a EventsFrame only containing the events with result COMPLETE into() , starts_inside() , starts_outside() , ends_inside() , ends_outside() : are all similar. They take one or more Zones or Area (see the tactical section) and filter events depending on whether they start, end, etc in that Zones . Zones will be able to be defined by the user, or use any of the ones defined in the package (link to Tactical) module to be added later to the documentation. These methods can also be chained, so if you wanted to filter by completed passes into the opponents box you can do: EventsFrame.type(\"PASS\").into(Zones.OPPONENT_BOX).result(\"COMPLETE\") CodesFrame A CodeballFrame that holds codes from an xml file. The columns present on this CodeballFrame will depend on how your XML is format, but as a general rule you'll see one row per code , with columns for the code_id , timestamp , end_timestamp , code (name) and then one column for each tag.","title":"CodeballFrames"},{"location":"codeball-frames/#whats-a-codeballframe","text":"CodeballFrames are subclasses of Pandas DataFrames. They have all the methods of a standard DataFrame, but have additional methods and attributes that make it easier to work, filter, and handle data from the game. The base class is BaseFrame , and the main CodeballFrame classes are TrackingFrame and EventsFrame . An important aspect of CodeballFrame, as it is the case for DataFrames, is that methods can be chained.","title":"What's a CodeballFrame?"},{"location":"codeball-frames/#baseframe","text":"","title":"BaseFrame"},{"location":"codeball-frames/#attributes-properties","text":"All CodeballFrame have 3 attributes: records: this holds the records from the datasets created by Kloppy when reading in the data. This attribute is not passed to the result of any action that modifies the data frame. metadata: this holds the metadata from the datasets created by Kloppy when reading in the data. This attribute is preserved when filtering or modifying the data frame. However is lost if the result is a series. data_type: this indicates what type of data the data frame holds. For example DataType.TRACKING or DataType.EVENT","title":"Attributes / properties"},{"location":"codeball-frames/#methods","text":"get_team_by_id get_period_by_id get_other_team_id","title":"Methods"},{"location":"codeball-frames/#trackingframe","text":"A CodeballFrame that holds tracking data.","title":"TrackingFrame"},{"location":"codeball-frames/#methods_1","text":"team() : TrackingFrame.team(team_id) will return a TrackingFrame only containing the columns that have data for team with id team_id. dimension() : TrackingFrame.dimension('x') will return a TrackingFrame only containing the columns with data on the x axis. players() : TrackingFrame.players('field') will return a TrackingFrame only containing the columns with data for the field players (excluding goalkeeper). TrackingFrame.players() will return a TrackingFrame containing the data for all players but drop all the other columns. phase() : TrackingFrame.phase(defending_team=team_id) will return a Series with True on the frames the team with id team_id was defending and False otherwise. stretched() : TrackingFrame.stretched(50) will return a Series with True on the frames the stretched of the values in the columns of the TrackingFrame is higher than the threshold. Since all these methods can be chained, is you want to get the x coordinates of field players for team with id team_id , you can do: TrackingDataFrame.team(team_id).players(field).dimension('x')","title":"Methods"},{"location":"codeball-frames/#eventsframe","text":"A CodeballFrame that holds event data.","title":"EventsFrame"},{"location":"codeball-frames/#methods_2","text":"type() : This allows to filter by the type column. EventsFrame.type('PASS') will return a EventsFrame only containing the rows that correspond to PASS type events. result() : This allows to filter by the result column. EventsFrame.result('COMPLETE') will return a EventsFrame only containing the events with result COMPLETE into() , starts_inside() , starts_outside() , ends_inside() , ends_outside() : are all similar. They take one or more Zones or Area (see the tactical section) and filter events depending on whether they start, end, etc in that Zones . Zones will be able to be defined by the user, or use any of the ones defined in the package (link to Tactical) module to be added later to the documentation. These methods can also be chained, so if you wanted to filter by completed passes into the opponents box you can do: EventsFrame.type(\"PASS\").into(Zones.OPPONENT_BOX).result(\"COMPLETE\")","title":"Methods"},{"location":"codeball-frames/#codesframe","text":"A CodeballFrame that holds codes from an xml file. The columns present on this CodeballFrame will depend on how your XML is format, but as a general rule you'll see one row per code , with columns for the code_id , timestamp , end_timestamp , code (name) and then one column for each tag.","title":"CodesFrame"},{"location":"format-for-play/","text":"Patterns and events format for Play This documentation describes the API to import into import events with annotations associated to them into Play. We refer to this type of events as patterns . Patterns are imported into Play via a json file with a .patt extension. Below an explanation of how this file should be formatted. This documentation is compatible with versions 2.5.0 of Play by Metrica Sports or higher. Old patterns files are still supported, see section Versions . Format The patterns files is in JSON format. It has to main entry points: events and insert The events entry is an array containing all the events you detect for each game. Those events are going to be stored and associated to the game you are uploading them to. The insert entry is an object that will contain a declaration of patterns , tags and tag_groups you want to create. It's important to notice that this will be created and store in the database and will be shared among all you games. You don't need to create all the patterns, tags and groups each time. If you want to add them to all of your files, that's not a problem. As long the unique code you added to any of them is already in the database there will be no duplicates. You can use the insert field for updating your patterns, tags and tag_groups. More on that in the Patterns, Tags and Tag Groups sections. { \"events\": [ // Here you'll list al events you want to create ], \"insert\": { \"patterns\": [ // By listing patterns here you'll be able to create // and update patterns ], \"tag_groups\": [ // By listing tag groups here you'll be able to create // and update tag groups ], \"tags\": [ // By listing tags here you'll be able to create // and update tags ] } } Prefix Every time you want to create something in our database, like a Pattern, Tag Group or Tag you'll need to add a code to it. You can manage your codes any way you like as long you create unique codes for each resource. We'll provide you wit a prefix you'll need to add to your codes. If a resource you want to create doesn't have the appropriate prefix it will be omitted. Let's say you want to create some patterns and your prefix is RCNG. You could do something like RCNG_001 and RCNG_002 or RCNG_COUNTER and RCNG_POSESSION . It's up to you how you manage codes, but the prefix is mandatory. Patterns We call Pattern to a type of detection. Let's say you create an algorithm for detecting Counter-attacks. You'll create a Pattern called Counter-Attacks and each Counter-attack you detect will be an event associated to this Pattern. A Pattern needs to have a unique code and a name, that's it. If a code already exists on the database it would not create the pattern again it will update the name to what's written in the current file. It's important to remember that Patterns are shared by all your games, so updating the name will have an effect on previous and future games. \"patterns\": [ { \"name\": \"Counter Attack\", \"code\": \"RCNG_001\" }, { \"name\": \"Defensive Positioning\", \"code\": \"RCNG_002\" } ], This is how patterns will be listed in Play for each game: Tags and Tag Groups For any given Pattern you create, most likely you'll want to create some Tags and Tag Groups as well. Let's say you have your Counter Attacks pattern and you want to be able to filter by \"Fast\" and \"Slow\", or \"Successful\" and \"Failed\". For that you can create Tags. And those Tags can be grouped. For example, \"Fast\" and \"Slow\" could be two tags on the group \"Counter Speed\". For creating a Tag Group you only need to add a unique code and a name. For creating a Tag you'll need to add a unique code, a name and the code of the group the tags belongs to. \"tag_groups\": [ { \"name\": \"Counter Speed\", \"code\": \"RCNG_GROUP_001\" }, { \"name\": \"Counter Quality\", \"code\": \"RCNG_GROUP_002\" } ], \"tags\": [ { \"name\": \"Fast\", \"code\": \"RCNG_TAG_001\", \"group\": \"RCNG_GROUP_001\" }, { \"name\": \"Slow\", \"code\": \"RCNG_TAG_002\", \"group\": \"RCNG_GROUP_001\" } ], You'll see Tags organized by groups in the filter section when a Pattern is selected Once you create a Tag Group, and associate a Tag with it, the tag associated to a group will always be organized based no that group. An important point. Players and Team codes, for example ESPBCN or P030 can be used as tags directly. So no need to create tags for teams and players. Just use them as any other tags you have created. Creating and updating This information about patterns, tags and tag groups, can be included every time the json is uploaded. However they are only needed when you want to create one of them, or when you want to update on of them (e.g. change name). Events On event is one detection of a Pattern. Events happen at a given time in the video and have a duration and many other properties. An Events belongs to a Pattern and has Tags associated to it. This is how, when you select a Pattern you will see a list with all the Events belonging to that Pattern. And when you select an event you will see a list with all the tags added to that Event. This is how you construct events. There are three main categories of concepts. 1) One is the information about the event itself. 2) Another is the information about the annotations. 3) The last one is the tags and team information for filtering in Play. An example event with annotations looks like this: { \"pattern\": RCNG_PATTERN_001, \"start_time\": 5000, \"event_time\": 10000, \"end_time\": 25000, \"coordinates\": [ [0.39,0.51], [0.44,0.42] ], \"visualizations\": { \"start_time\": 7000, \"end_time\": 23000, \"players\": \"P030\", \"tool_id\": \"players\", \"options\": { \"speed\": 1 }, \"version\": 2 }, \"tags\": [ \"ESPBCN\", \"P030\", \"RCGN_TAG_001\", \"RCGN_TAG_007\" ], \"team\": \"ESPBCN\" } This is an example of a sprint type event which has a speed visualization. This is an event that belongs to the pattern code RCNG_PATTERN_001 , that starts at time 5000 and ends at time 25000 , with the event indicator being located at 10000 in the timeline of the video. All times are in milliseconds. In this case, in Play the event will be located at time 10000 in the timeline that , but when you select it, the video will play from time 5000 to 25000 . Moreover, this event has coordinates. There are two options for coordinates. If you provide just a pair of xy coordinates, it will show a dot on the 2D field in Play. If you provide two pairs, it will show an arrow. In this case it will show an arrow in the 2D field (NOT in the video) going from [0.39, 0.51] to [0.44, 0.42] . This event also has a annotation. In this case, the speed will show up for this player from time 7000 to 23000 for player P030 . To code for that, the tool_id is set to players type visualization that has speed as 1 (true). This visualization is also of version = 2 , which means it's formatted for the new visualizations in version 2.5.0 of Play and onwards. See section Versions . Finally, this event has the tags \"ESPBCN\",\"P030\",RCGN_TAG_001,RCGN_TAG_007 and belongs to the team ESPBCN . Below a summary of the information about fields related events and fields related to annotations. Fields common to all events { \"pattern\": 15, // Pattern code \"start_time\": 5000, // Number in milliseconds \"event_time\": 10000, // Number in milliseconds \"end_time\": 25000, // Number in milliseconds \"coordinates\": [ // In normalized coordinates. `null` if empty. [0.39,0.51], [0.44,0.42] ] \"visualizations\":[...], // See below. `null` if empty. \"tags\": [ // Codes of the tags. `[]` if empty. \"ESPBCN\", \"P030\" ], \"team\": \"ESPBCN\" // `null` if empty. } Fields common to all visualizations The following attributes have to be defined for each tool. Annotations' order matters, they will be created and displayed in the same order they are declared, first annotation will be rendered at the bottom/background. { start_time : 1040, // Milliseconds end_time : 2130, // Milliseconds tool_id : 'players', // The ID of the tool ... // Each tool could have other mandatory attributes (players, team, points, etc.) options : {}, // Optional object attribute for the tool version : 2 // Which version of API it's the viz compatible with } Versions In version 2.5.0 of Play by Metrica Sports we introduced new and improved visualizations . These new visualizations add several new parameters and options to the visualizations, thus the API for adding visualizations has changed. In particular around the available options for each type of visualization. For example whereas on the original version (version 1), to define a ring you would do: { start_time : 1040, end_time : 2130, tool_id : 'players', players : ['P001', 'P002'], options : { ring: true, color: '#FFFFFF' }, } On the new version (version 2) rings have a border and a fill that can de defined separately. So to define a ring you need to do: { start_time : 1040, end_time : 2130, tool_id : 'players', players : ['P001', 'P002'], options : { ringFill: true, ringBorder: true, ringFillColor: '#FFFFFF', ringBorderColor: '#FFFF00' }, version : 2 } Note that in the last one we noted that this visualization is of version 2 so that the API know how to read this visualization. However, while different in formats, the API on version 2.5.0 onwards is compatible with older versions. If a visualization doesn't have a version indicated in the options it will be assumed it's from version 2, and the options will be populated accordingly. For example, if you import the above example of a version 1 ring, it would be like importing: { start_time : 1040, end_time : 2130, tool_id : 'players', players : ['P001', 'P002'], options : { ringFill: true, ringBorder: true, ringFillColor: '#FFFFFF', ringBorderColor: '#FFFFFF' }, version : 2 }","title":"File Formatting"},{"location":"format-for-play/#patterns-and-events-format-for-play","text":"This documentation describes the API to import into import events with annotations associated to them into Play. We refer to this type of events as patterns . Patterns are imported into Play via a json file with a .patt extension. Below an explanation of how this file should be formatted. This documentation is compatible with versions 2.5.0 of Play by Metrica Sports or higher. Old patterns files are still supported, see section Versions .","title":"Patterns and events format for Play"},{"location":"format-for-play/#format","text":"The patterns files is in JSON format. It has to main entry points: events and insert The events entry is an array containing all the events you detect for each game. Those events are going to be stored and associated to the game you are uploading them to. The insert entry is an object that will contain a declaration of patterns , tags and tag_groups you want to create. It's important to notice that this will be created and store in the database and will be shared among all you games. You don't need to create all the patterns, tags and groups each time. If you want to add them to all of your files, that's not a problem. As long the unique code you added to any of them is already in the database there will be no duplicates. You can use the insert field for updating your patterns, tags and tag_groups. More on that in the Patterns, Tags and Tag Groups sections. { \"events\": [ // Here you'll list al events you want to create ], \"insert\": { \"patterns\": [ // By listing patterns here you'll be able to create // and update patterns ], \"tag_groups\": [ // By listing tag groups here you'll be able to create // and update tag groups ], \"tags\": [ // By listing tags here you'll be able to create // and update tags ] } }","title":"Format"},{"location":"format-for-play/#prefix","text":"Every time you want to create something in our database, like a Pattern, Tag Group or Tag you'll need to add a code to it. You can manage your codes any way you like as long you create unique codes for each resource. We'll provide you wit a prefix you'll need to add to your codes. If a resource you want to create doesn't have the appropriate prefix it will be omitted. Let's say you want to create some patterns and your prefix is RCNG. You could do something like RCNG_001 and RCNG_002 or RCNG_COUNTER and RCNG_POSESSION . It's up to you how you manage codes, but the prefix is mandatory.","title":"Prefix"},{"location":"format-for-play/#patterns","text":"We call Pattern to a type of detection. Let's say you create an algorithm for detecting Counter-attacks. You'll create a Pattern called Counter-Attacks and each Counter-attack you detect will be an event associated to this Pattern. A Pattern needs to have a unique code and a name, that's it. If a code already exists on the database it would not create the pattern again it will update the name to what's written in the current file. It's important to remember that Patterns are shared by all your games, so updating the name will have an effect on previous and future games. \"patterns\": [ { \"name\": \"Counter Attack\", \"code\": \"RCNG_001\" }, { \"name\": \"Defensive Positioning\", \"code\": \"RCNG_002\" } ], This is how patterns will be listed in Play for each game:","title":"Patterns"},{"location":"format-for-play/#tags-and-tag-groups","text":"For any given Pattern you create, most likely you'll want to create some Tags and Tag Groups as well. Let's say you have your Counter Attacks pattern and you want to be able to filter by \"Fast\" and \"Slow\", or \"Successful\" and \"Failed\". For that you can create Tags. And those Tags can be grouped. For example, \"Fast\" and \"Slow\" could be two tags on the group \"Counter Speed\". For creating a Tag Group you only need to add a unique code and a name. For creating a Tag you'll need to add a unique code, a name and the code of the group the tags belongs to. \"tag_groups\": [ { \"name\": \"Counter Speed\", \"code\": \"RCNG_GROUP_001\" }, { \"name\": \"Counter Quality\", \"code\": \"RCNG_GROUP_002\" } ], \"tags\": [ { \"name\": \"Fast\", \"code\": \"RCNG_TAG_001\", \"group\": \"RCNG_GROUP_001\" }, { \"name\": \"Slow\", \"code\": \"RCNG_TAG_002\", \"group\": \"RCNG_GROUP_001\" } ], You'll see Tags organized by groups in the filter section when a Pattern is selected Once you create a Tag Group, and associate a Tag with it, the tag associated to a group will always be organized based no that group. An important point. Players and Team codes, for example ESPBCN or P030 can be used as tags directly. So no need to create tags for teams and players. Just use them as any other tags you have created.","title":"Tags and Tag Groups"},{"location":"format-for-play/#creating-and-updating","text":"This information about patterns, tags and tag groups, can be included every time the json is uploaded. However they are only needed when you want to create one of them, or when you want to update on of them (e.g. change name).","title":"Creating and updating"},{"location":"format-for-play/#events","text":"On event is one detection of a Pattern. Events happen at a given time in the video and have a duration and many other properties. An Events belongs to a Pattern and has Tags associated to it. This is how, when you select a Pattern you will see a list with all the Events belonging to that Pattern. And when you select an event you will see a list with all the tags added to that Event. This is how you construct events. There are three main categories of concepts. 1) One is the information about the event itself. 2) Another is the information about the annotations. 3) The last one is the tags and team information for filtering in Play. An example event with annotations looks like this: { \"pattern\": RCNG_PATTERN_001, \"start_time\": 5000, \"event_time\": 10000, \"end_time\": 25000, \"coordinates\": [ [0.39,0.51], [0.44,0.42] ], \"visualizations\": { \"start_time\": 7000, \"end_time\": 23000, \"players\": \"P030\", \"tool_id\": \"players\", \"options\": { \"speed\": 1 }, \"version\": 2 }, \"tags\": [ \"ESPBCN\", \"P030\", \"RCGN_TAG_001\", \"RCGN_TAG_007\" ], \"team\": \"ESPBCN\" } This is an example of a sprint type event which has a speed visualization. This is an event that belongs to the pattern code RCNG_PATTERN_001 , that starts at time 5000 and ends at time 25000 , with the event indicator being located at 10000 in the timeline of the video. All times are in milliseconds. In this case, in Play the event will be located at time 10000 in the timeline that , but when you select it, the video will play from time 5000 to 25000 . Moreover, this event has coordinates. There are two options for coordinates. If you provide just a pair of xy coordinates, it will show a dot on the 2D field in Play. If you provide two pairs, it will show an arrow. In this case it will show an arrow in the 2D field (NOT in the video) going from [0.39, 0.51] to [0.44, 0.42] . This event also has a annotation. In this case, the speed will show up for this player from time 7000 to 23000 for player P030 . To code for that, the tool_id is set to players type visualization that has speed as 1 (true). This visualization is also of version = 2 , which means it's formatted for the new visualizations in version 2.5.0 of Play and onwards. See section Versions . Finally, this event has the tags \"ESPBCN\",\"P030\",RCGN_TAG_001,RCGN_TAG_007 and belongs to the team ESPBCN . Below a summary of the information about fields related events and fields related to annotations.","title":"Events"},{"location":"format-for-play/#fields-common-to-all-events","text":"{ \"pattern\": 15, // Pattern code \"start_time\": 5000, // Number in milliseconds \"event_time\": 10000, // Number in milliseconds \"end_time\": 25000, // Number in milliseconds \"coordinates\": [ // In normalized coordinates. `null` if empty. [0.39,0.51], [0.44,0.42] ] \"visualizations\":[...], // See below. `null` if empty. \"tags\": [ // Codes of the tags. `[]` if empty. \"ESPBCN\", \"P030\" ], \"team\": \"ESPBCN\" // `null` if empty. }","title":"Fields common to all events"},{"location":"format-for-play/#fields-common-to-all-visualizations","text":"The following attributes have to be defined for each tool. Annotations' order matters, they will be created and displayed in the same order they are declared, first annotation will be rendered at the bottom/background. { start_time : 1040, // Milliseconds end_time : 2130, // Milliseconds tool_id : 'players', // The ID of the tool ... // Each tool could have other mandatory attributes (players, team, points, etc.) options : {}, // Optional object attribute for the tool version : 2 // Which version of API it's the viz compatible with }","title":"Fields common to all visualizations"},{"location":"format-for-play/#versions","text":"In version 2.5.0 of Play by Metrica Sports we introduced new and improved visualizations . These new visualizations add several new parameters and options to the visualizations, thus the API for adding visualizations has changed. In particular around the available options for each type of visualization. For example whereas on the original version (version 1), to define a ring you would do: { start_time : 1040, end_time : 2130, tool_id : 'players', players : ['P001', 'P002'], options : { ring: true, color: '#FFFFFF' }, } On the new version (version 2) rings have a border and a fill that can de defined separately. So to define a ring you need to do: { start_time : 1040, end_time : 2130, tool_id : 'players', players : ['P001', 'P002'], options : { ringFill: true, ringBorder: true, ringFillColor: '#FFFFFF', ringBorderColor: '#FFFF00' }, version : 2 } Note that in the last one we noted that this visualization is of version 2 so that the API know how to read this visualization. However, while different in formats, the API on version 2.5.0 onwards is compatible with older versions. If a visualization doesn't have a version indicated in the options it will be assumed it's from version 2, and the options will be populated accordingly. For example, if you import the above example of a version 1 ring, it would be like importing: { start_time : 1040, end_time : 2130, tool_id : 'players', players : ['P001', 'P002'], options : { ringFill: true, ringBorder: true, ringFillColor: '#FFFFFF', ringBorderColor: '#FFFFFF' }, version : 2 }","title":"Versions"},{"location":"game-dataset/","text":"What's a GameDataset? A GameDataset is a class that serves 2 purposes: Hold CodeballFrames for tracking, event, and other data types Provide methods to enrich those CodeballFrames Provide auxiliary methods to process and handle data that require information from the game_dataset (e.g. frame rate) Attributes tracking : contains a TrackingFrame events : contains an EventsFrame Properties game_dataset_type : return an Enum with the type of the dataset, which could be [ONLY_TRACKING, ONLY_EVENTS, FULL_SAME_PROVIDER, FULL_MIXED_PROVIDERS] metadata : the metadata of the dataset (unless it's a FULL_MIXED_PROVIDERS type) that comes from loading the data with kloppy. Enrichment methods There is a main method _enrich_data that runs all the below: _build_possessions _set_periods_attacking_direction _enrich_events _enrich_tracking Auxiliar methods find_interval : given a Series of bool values computes the intervals of True values. frame_to_milliseconds : given a frame number it returns the value in milliseconds of that moment in the video.","title":"GameDataset"},{"location":"game-dataset/#whats-a-gamedataset","text":"A GameDataset is a class that serves 2 purposes: Hold CodeballFrames for tracking, event, and other data types Provide methods to enrich those CodeballFrames Provide auxiliary methods to process and handle data that require information from the game_dataset (e.g. frame rate)","title":"What's a GameDataset?"},{"location":"game-dataset/#attributes","text":"tracking : contains a TrackingFrame events : contains an EventsFrame","title":"Attributes"},{"location":"game-dataset/#properties","text":"game_dataset_type : return an Enum with the type of the dataset, which could be [ONLY_TRACKING, ONLY_EVENTS, FULL_SAME_PROVIDER, FULL_MIXED_PROVIDERS] metadata : the metadata of the dataset (unless it's a FULL_MIXED_PROVIDERS type) that comes from loading the data with kloppy.","title":"Properties"},{"location":"game-dataset/#enrichment-methods","text":"There is a main method _enrich_data that runs all the below: _build_possessions _set_periods_attacking_direction _enrich_events _enrich_tracking","title":"Enrichment methods"},{"location":"game-dataset/#auxiliar-methods","text":"find_interval : given a Series of bool values computes the intervals of True values. frame_to_milliseconds : given a frame number it returns the value in milliseconds of that moment in the video.","title":"Auxiliar methods"},{"location":"how-to-import-to-play/","text":"Once you have created a .patt file, you can import it to Metrica Play via Metrica Cloud . To do so you need to select the Video Project you want to upload a file and upload it under the more options section (three dots all the way to the left of the Video Project). You'll get a notification informing you if the upload was or wasn't successful. Once the file is uploaded, you can go to Metrica Play and download the Video Project from the DB Manager. If you already did that, you can: Select the Video Project in the Video manager, and then on Pattern Events more options select Retry download. Close and open the application again and will get a notification informing you there is a new file and you can click directly there to download it. If you had uploaded a file already and want to upload a new one, go to Cloud, delete the previously uploaded file and do any of the two steps described above.","title":"How to import a file"},{"location":"metrica-play-api/","text":"What can you do with Play's API? Note that to import a pattern file to Play you do not need to use codeball. As long as the file you import is formatted as this documentation indicates you'll be able to import the file. How you create that file can be any language, any library. Codeball is one way to do it, but not the only one! Feel free to use whatever language or library/is you feel more comfortable with! Play API for patterns and visualizations allows you to import patterns and events into Play. The interesting part is that not only it allows you to import events that have a start/end time, tags, etc; but also to add visualizations directly from the code. For example the following json code: { \"pattern\": \"RCNG_PATTERN_001\", \"start_time\": 5000, \"event_time\": 10000, \"end_time\": 25000, \"coordinates\": [ [0.39,0.51], [0.44,0.42] ], \"visualizations\": { \"start_time\": 7000, \"end_time\": 23000, \"players\": \"P030\", \"tool_id\": \"players\", \"options\": { \"speed\": 1 }, \"version\": 2 }, \"tags\": [ \"ESPBCN\", \"P030\", \"RCGN_TAG_001\", \"RCGN_TAG_007\" ], \"team\": \"ESPBCN\" } This is an example of a sprint type event which has a speed visualization. This event belongs to the pattern code RCNG_PATTERN_001 , that starts at time 5000 and ends at time 25000 , with the event indicator being located at 10000 in the timeline of the video. All times are in milliseconds. In this case, in Play the event will be located at time 10000 in the timeline that , but when you select it, the video will play from time 5000 to 25000 . Moreover, this event has coordinates. There are two options for coordinates. If you provide just a pair of xy coordinates, it will show a dot on the 2D field in Play. If you provide two pairs, it will show an arrow. In this case it will show an arrow in the 2D field (NOT in the video) going from [0.39, 0.51] to [0.44, 0.42] . This event also has a annotation. In this case, the speed will show up for this player from time 7000 to 23000 for player P030 . To code for that, the tool_id is set to players type visualization that has speed as 1 (true). This visualization is also of version = 2, which means it's formatted for the new visualizations in version 2.5.0 of Play and onwards. See section Versions. Finally, this event has the tags \"ESPBCN\",\"P030\",RCGN_TAG_001,RCGN_TAG_007 and belongs to the team ESPBCN . And by producing this file and importing it to Play via Metrica Cloud, you'll see this result automatically. Import to Play To import a json file to Play, you have to do it via the video project created in Metrica Cloud. To do so go to this option on your video project:","title":"What you can do"},{"location":"metrica-play-api/#what-can-you-do-with-plays-api","text":"Note that to import a pattern file to Play you do not need to use codeball. As long as the file you import is formatted as this documentation indicates you'll be able to import the file. How you create that file can be any language, any library. Codeball is one way to do it, but not the only one! Feel free to use whatever language or library/is you feel more comfortable with! Play API for patterns and visualizations allows you to import patterns and events into Play. The interesting part is that not only it allows you to import events that have a start/end time, tags, etc; but also to add visualizations directly from the code. For example the following json code: { \"pattern\": \"RCNG_PATTERN_001\", \"start_time\": 5000, \"event_time\": 10000, \"end_time\": 25000, \"coordinates\": [ [0.39,0.51], [0.44,0.42] ], \"visualizations\": { \"start_time\": 7000, \"end_time\": 23000, \"players\": \"P030\", \"tool_id\": \"players\", \"options\": { \"speed\": 1 }, \"version\": 2 }, \"tags\": [ \"ESPBCN\", \"P030\", \"RCGN_TAG_001\", \"RCGN_TAG_007\" ], \"team\": \"ESPBCN\" } This is an example of a sprint type event which has a speed visualization. This event belongs to the pattern code RCNG_PATTERN_001 , that starts at time 5000 and ends at time 25000 , with the event indicator being located at 10000 in the timeline of the video. All times are in milliseconds. In this case, in Play the event will be located at time 10000 in the timeline that , but when you select it, the video will play from time 5000 to 25000 . Moreover, this event has coordinates. There are two options for coordinates. If you provide just a pair of xy coordinates, it will show a dot on the 2D field in Play. If you provide two pairs, it will show an arrow. In this case it will show an arrow in the 2D field (NOT in the video) going from [0.39, 0.51] to [0.44, 0.42] . This event also has a annotation. In this case, the speed will show up for this player from time 7000 to 23000 for player P030 . To code for that, the tool_id is set to players type visualization that has speed as 1 (true). This visualization is also of version = 2, which means it's formatted for the new visualizations in version 2.5.0 of Play and onwards. See section Versions. Finally, this event has the tags \"ESPBCN\",\"P030\",RCGN_TAG_001,RCGN_TAG_007 and belongs to the team ESPBCN . And by producing this file and importing it to Play via Metrica Cloud, you'll see this result automatically.","title":"What can you do with Play's API?"},{"location":"metrica-play-api/#import-to-play","text":"To import a json file to Play, you have to do it via the video project created in Metrica Cloud. To do so go to this option on your video project:","title":"Import to Play"},{"location":"patterns/","text":"Configuration All the patterns below, are available included in Codeball and ready to be used. They have a default configuration included with the package, but you can create your own config file if you want to change for example, the name of the patterns, the in and out time, or the parameters the use to compute events. The configuration for a pattern looks like the below. For more details check the example pattern in the Examples section. { \"include\": true, \"name\": \"Passes into the box\", \"code\": \"MET_003\", \"pattern_class\": \"PassesIntoTheBox\", \"parameters\": null, \"in_time\": 2, \"out_time\": 2 } Available patterns TeamStretched This pattern looks for moments in which the team is stretched horizontally while defending for more than 5 seconds. It returns those moments with a TeamSize length visualization for the duration of the infringement. This pattern doesn't add anything on the 2D field. Parameters: team: str -> Code of the team you want to analyze threshold: float -> What is the stretch threshold in meters In this example the threshold is at 35 meters. SetPieces This pattern return set Pieces include: kick offs, throw ins, corner kicks penalties, free kicks. Beside indicating the moment of the game in which they tke place, it adds a spotlight on the player tacking the set piece. This pattern also adds a dot on the 2D field for each event. PassesIntoTheBox This pattern finds completed passes into the opponent box. For each one of those passes, it creates a pattern event that at the moment of the pass makes a 2s pause and draws an arrow on the video showing the pass. This pattern also adds an arrow on the 2D field for each event.","title":"Patterns"},{"location":"patterns/#configuration","text":"All the patterns below, are available included in Codeball and ready to be used. They have a default configuration included with the package, but you can create your own config file if you want to change for example, the name of the patterns, the in and out time, or the parameters the use to compute events. The configuration for a pattern looks like the below. For more details check the example pattern in the Examples section. { \"include\": true, \"name\": \"Passes into the box\", \"code\": \"MET_003\", \"pattern_class\": \"PassesIntoTheBox\", \"parameters\": null, \"in_time\": 2, \"out_time\": 2 }","title":"Configuration"},{"location":"patterns/#available-patterns","text":"","title":"Available patterns"},{"location":"patterns/#teamstretched","text":"This pattern looks for moments in which the team is stretched horizontally while defending for more than 5 seconds. It returns those moments with a TeamSize length visualization for the duration of the infringement. This pattern doesn't add anything on the 2D field. Parameters: team: str -> Code of the team you want to analyze threshold: float -> What is the stretch threshold in meters In this example the threshold is at 35 meters.","title":"TeamStretched"},{"location":"patterns/#setpieces","text":"This pattern return set Pieces include: kick offs, throw ins, corner kicks penalties, free kicks. Beside indicating the moment of the game in which they tke place, it adds a spotlight on the player tacking the set piece. This pattern also adds a dot on the 2D field for each event.","title":"SetPieces"},{"location":"patterns/#passesintothebox","text":"This pattern finds completed passes into the opponent box. For each one of those passes, it creates a pattern event that at the moment of the pass makes a 2s pause and draws an arrow on the video showing the pass. This pattern also adds an arrow on the 2D field for each event.","title":"PassesIntoTheBox"},{"location":"tactical/","text":"Tactical Module The tactical module includes different classes and methods to help work with the data from a tactical perspective. Areas An Area is a class used to define an area of the pitch. You can define simple rectangular areas, or more complex polygonal ones. To define an area you need to provide 2 or more points (in normalized coordinates, for example (0.5,0.5) would be the center of the pitch). If you provide only two points it will define a rectangular area, in which the first point is the top-left one and the second one is the bottom-right one. If you provide 3 or more points it will be consider a polygon. Areas have a type attribute that will return an Enum with either AreaType.RECTANGLE or AreaType.POLYGON . Zones Zones is an Enum that defines a list of zones that are tactically relevant. Each type could be defined by one or more Area . The list of currently defined Zones is: OPPONENT_BOX OWN_BOX ATTACKING_THIRD MIDDLE_THIRD DEFENDING_THIRD OWN_HALF OPPONENT_HALF LEFT_HALF_SPACE RIGHT_HALF_SPACE HALF_SPACES CENTRE LEFT_WING RIGHT_WING WINGS ZONE_14 Using Areas and Zones You can use Areas and Zones in the methods provided by CodeballFrames . For example you can do: EventsFrame.into(Zones.HALF_SPACES) Or you can define your own areas and then provide them as filters: custom_area = Area((0.16,0),(0.84,1)) EventsFrame.into(custom_area) Finally, you can combine and provide one or more areas/zones, or a mix of zones and areas: custom_area = Area((0.16,0),(0.84,1)) EventsFrame.into(Zones.HALF_SPACES,custom_area)","title":"Tactical"},{"location":"tactical/#tactical-module","text":"The tactical module includes different classes and methods to help work with the data from a tactical perspective.","title":"Tactical Module"},{"location":"tactical/#areas","text":"An Area is a class used to define an area of the pitch. You can define simple rectangular areas, or more complex polygonal ones. To define an area you need to provide 2 or more points (in normalized coordinates, for example (0.5,0.5) would be the center of the pitch). If you provide only two points it will define a rectangular area, in which the first point is the top-left one and the second one is the bottom-right one. If you provide 3 or more points it will be consider a polygon. Areas have a type attribute that will return an Enum with either AreaType.RECTANGLE or AreaType.POLYGON .","title":"Areas"},{"location":"tactical/#zones","text":"Zones is an Enum that defines a list of zones that are tactically relevant. Each type could be defined by one or more Area . The list of currently defined Zones is: OPPONENT_BOX OWN_BOX ATTACKING_THIRD MIDDLE_THIRD DEFENDING_THIRD OWN_HALF OPPONENT_HALF LEFT_HALF_SPACE RIGHT_HALF_SPACE HALF_SPACES CENTRE LEFT_WING RIGHT_WING WINGS ZONE_14","title":"Zones"},{"location":"tactical/#using-areas-and-zones","text":"You can use Areas and Zones in the methods provided by CodeballFrames . For example you can do: EventsFrame.into(Zones.HALF_SPACES) Or you can define your own areas and then provide them as filters: custom_area = Area((0.16,0),(0.84,1)) EventsFrame.into(custom_area) Finally, you can combine and provide one or more areas/zones, or a mix of zones and areas: custom_area = Area((0.16,0),(0.84,1)) EventsFrame.into(Zones.HALF_SPACES,custom_area)","title":"Using Areas and Zones"},{"location":"visualizations/","text":"Visualizations types and settings This section describes all the possible visualizations that can be added to an event, as well as the API to be imported into Play. For each one of these possibilities, there is a dataclass defined in visualizations.py so that they can be easily added from the code. Fields common to all visualizations The following attributes have to be defined for each tool. Annotations' order matters, they will be created and displayed in the same order they are declared, first annotation will be rendered at the bottom/background. { start_time : 1040, // Milliseconds end_time : 2130, // Milliseconds tool_id : 'players', // The ID of the tool ... // Each tool could have other mandatory attributes options : {}, // Optional object attribute for the tool version : 2 // Which version of API it's the viz compatible with } Tools This is a list of all the tools that is possible to add as annotations. Each option of each tool is optional. If you don't include some of them, default value will be used. The options attribute and the children of it are optional. If you don't include some or all of them, default values will be used Players The tool_id is players . Players players: ['P001', 'P002'] Options options: { id : false, speed : false, size : 1.0, // [0.2, 2.5] color : '#000000', boxPositionDown : false, spotlight : false, spotlightSize : 0.5, // Multiplier [0.2, 4.0] spotlightColor : '#FFFFFF', spotlightOpacity : 0.43, // [0.0, 1.0] spotlightHeight : 2.0, // [0.1, 10.0] ringSize : 0.73, ringBorder : false, ringBorderColor : '#FFFFFF', ringFill : false, ringFillColor : '#DC3322', is3d : false } Trails The tool_id is trails . Players players: ['P001', 'P002'] Options options: { color: '#0062ad', continuous: true, dotted: false, dashSize: 1.0, // Multiplier [0.2, 2.5]. Only Dotted is3d: false, ringBorder: true, offsetOpacity: 0.26, // [0.0, 1.0] opacity: 1.0, // [0.0, 1.0] ringBorderColor: \"#ffffff\", ringFill: true, ringFillColor: '#009cdd', ringSize: 1.0, // Multiplier [0.6, 4.0] seconds: 5.0, // [1.0, 99.0] thickness: 0.1, // Multiplier [0.1, 5.0]. Only in 3D width: 0.24 // Multiplier [0.1, 2.0] } Future Trails The tool_id is futureTrails . Players players: ['P001', 'P002'] Options options: { color: '#ff9e2d', continuous: true, dashSize: 0.6, // Multiplier [0.2, 2.5]. Only Dotted dotted: false, is3d: false, offsetOpacity: 0.05, // [0.0, 1.0] opacity: 1.0, // [0.0, 1.0] ringBorder: true, ringBorderColor: \"#ffffff\", ringFill: true, ringFillColor: '#ffdc3a', ringSize: 1.0, // Multiplier [0.6, 4.0] seconds: 5.0, // [1.0, 99.0] thickness: 0.23, // Multiplier [0.1, 5.0]. Only in 3D width: 0.29 // Multiplier [0.1, 2.0] } Magnifiers The tool_id is magnifiers . Players players: ['P001', 'P002'] Options options: { color: '#ffffff', zoom : 1.0, // [0.2, 1.5], size : 1.0 // [0.5, 1.5] } Measurer The tool_id is measurer . Players players: ['P001', 'P002'] Options options: { borderColor: '#dc3322', borderEdgeOpacity: 0.4, // [0.0, 1.0] borderOpacity: 0.9, // [0.0, 1.0] closed: false, continuous: true, dashSize: 1.45, // Multiplier [0.2, 2.5]. Only Dotted distance: true, distanceColor: '#ffffff', distanceIs3d: false, distancePosition: 0.92, // Multiplier [0.5, 2.0] distanceOpacity: 1.0, // [0.0, 1.0] distanceSize: 1.01, // Multiplier [0.5, 1.5] dotted: false, fillColor: '#dc3322', Only Closed fillOpacity: 0.42, // [0.0, 1.0] is3d: false, ringBorder: true, ringBorderColor: '#ffffff', ringFill: true, ringFillColor: '#dc3322', ringSize: 0.91, // Multiplier [0.6, 4.0] thickness: 0.13, // Multiplier [0.0, 5.0]. Only in 3D width: 0.23, // Multiplier [0.15, 2.0] } Team Size The tool_id is teamSize . Team team: 'T001' Line line: 'width' // Values: 'width' or 'length' Options options: { continuous: true, dotted: false, color: '#683391', x: 0.0, y: 0.0, width: 0.23, // [0.1, 5.0] edgeOpacity: 0.0, // [0.0, 1.0] opacity: 1.0, // [0.0, 1.0] thickness: 0.22, // Multiplier [0.0, 5.0]. Only in 3D dashSize: 0.6, // Multiplier [0.2, 2.5]. Only Dotted distance: true, distanceColor: '#ffffff', distancePosition: 1.12, // [0.5, 2.0] distanceOpacity: 1.0, // Multiplier [0.0, 1.0] distanceSize: 1.3, // Multiplier [0.5, 1.5] distanceIs3d: false, is3d: false } Tactical Lines The tool_id is tacticalLines . Team team: 'T001' Line line: 'defenders' // Values: 'defenders', 'midfielders' or 'strikers' Options options: { borderColor: \"#ffffff\", borderEdgeOpacity: 0.3, // [0.1, 1.0] borderOpacity: 1.0, // [0.0, 1.0] fillColor: \"#ffffff\", fillOpacity: 0.4, // [0.0, 1.0] closed: false, // Only used when line is 'midfielders' width: 0.23, // [0.1, 2.0] thickness: 0.3, // Multiplier [0.0, 5.0]. Only in 3D dashSize: 1.0, // Multiplier [0.2, 2.5]. Only Dotted continuous: true, dotted: false, is3d: false, ringBorder: true, ringBorderColor: \"#ffffff\", ringFill: true, ringFillColor: \"#ffffff\", ringSize: 0.6, // [0.6, 4.0] distance: true, distanceColor: \"#ffffff\", distancePosition: 0.5, // Multiplier [0.5, 2.0] distanceOpacity: 1.0, // [0.0, 1.0] distanceSize: 0.73, // [0.5, 1.5] distanceIs3d: false } Line 3D The tool_id is line3d . Points // Normalized points: { start : { x: 0.0, y: 0.0 }, end : { x: 0.0, y: 0.0 } } Options options: { arrowheadWidth: 1.5, // [0.99, 2.0] color: '#ff4f43', continuous: true, curvature: 0.0, // [-1.0, 1.0] dashSize: 0.4, // Multiplier [0.2, 2.5] distance: false, distanceColor: '#ffffff', distancePosition: 0.92, // Multiplier [0.5, 2.0] distanceOpacity: 1.0, // [0.0, 1.0] distanceSize: 1.01, // Multiplier [0.5, 4.0] distanceIs3d: false, dotted: false, dynamic: false, edgeOpacity: 0.2, // [0.0, 1.0] opacity: 0.9, // [0.0, 1.0] height: 0.075, // [0.0, 0.15] heightCenter: 0.0, // [-1.0, 1.0] is3d: false, pinned: false, thickness: 0.15, // Multiplier [0.0, 5.0] width: 0.5 // [0.1, 5.0] } Freehand The tool_id is freehand . Points // Normalized: screen-space or field-space if 'is3d' is enabled. points: [ { x: 0.0, y: 0.0 }, ..., { x: 0.0, y: 0.0 } ] Options options: { color: '#9edd34', arrowheadWidth: 3.0, // [0.99, 5.0] continuous: true, dashSize: 0.5, // Multiplier [0.2, 2.0]. Only Dotted dotted: false, offsetOpacity: 0.2, // [0.0, 1.0] opacity: 0.9, // [0.0, 1.0] is3d: false, pinned: false, thickness: 0.07, // Multiplier [0.0, 5.0]. Only in 3D width: 0.2 // [0.1, 0.2] } Circle The tool_id is circle . Center and Radius // Normalized: screen-space or field-space if 'is3d' is enabled. center: { x: 0.0, y: 0.0 }, radius: { x: 0.1, y: 0.1 } Options options: { borderColor: '#b3b3b3', borderOpacity: 1.0, // [0.0, 1.0] fillColor: '#ffdc3a', fillOpacity: 0.26, // [0.0, 1.0] fillSolid: true, fillPattern: false, is3d: false, pinned: false, thickness: 0.5, // Multiplier [0.0, 5.0]. Only in 3D width: 0.62 // [0.0, 3.0] } Shape The tool_id is shape . Points // Normalized: screen-space or field-space if 'is3d' is enabled. points: [ { x: 0.0, y: 0.0 }, ..., { x: 0.0, y: 0.0 } ] Options options: { borderColor: '#0062ad', borderOpacity: 1.0, // [0.1, 1.0] borderContinuous: false, borderDotted: true, closed: false, dashSize: 0.6, // Multiplier [0.5, 1.5]. Only Dotted distance: true, distanceColor: \"#ffffff\", distancePosition: 1.0, // Multiplier [0.5, 2.0] distanceOpacity: 1.0, // [0.0, 1.0] distanceSize: 1.0, // [0.5, 1.5] distanceIs3d: false, fillColor: '#0062ad', fillOpacity: 0.25, // [0.0, 1.0] fillSolid: true, fillPattern: false, is3d: false, pinned: false, thickness: 0.1, // Multiplier [0.0, 5.0]. Only in 3D width: 0.15 // [0.0, 2.0] } Arrow The tool_id is arrow . Points // Normalized: screen-space or field-space if 'is3d' is enabled. points: { start : { x: 0.0, y: 0.0 }, end : { x: 0.0, y: 0.0 } } Options options: { arrowheadWidth: 1.5, // [0.99, 2.0] color: '#ff4f43', continuous: true, curvature: 0.0, // Multiplier [-1.0, 1.0]. Only in 3D dashSize: 0.4, // Multiplier [0.2, 2.5]. Only Dotted distance: false, distanceColor: \"#ffffff\", distancePosition: 0.92, // Multiplier [0.5, 2.0] distanceOpacity: 1.0, // [0.0, 1.0] distanceSize: 1.01, // [0.5, 4.0] distanceIs3d: false, dotted: false, dynamic: false, edgeOpacity: 0.2, // [0.0, 1.0] opacity: 0.9, // [0.0, 1.0] height: 0.0, // [0.0, 0.15] heightCenter: 0.0, // [-1.0, 1.0] is3d: false, pinned: false, thickness: 0.15, // Multiplier [0.0, 5.0]. Only in 3D width: 0.5 // [0.1, 5.0] } Dragger The tool_id is dragger . Points // Normalized: screen-space only. Flag 'is3d' is only applied to arrow. points: { start : { x: 0.0, y: 0.0 }, end : { x: 0.0, y: 0.0 } } Options options: { arrowColor: '#ffdc3a', arrowContinuous: true, arrowDashSize: 0.6, // Multiplier [0.6, 2.5]. Only arrowDotted arrowDotted: false, arrowDynamic: false, arrowheadWidth: 2.0, // [0.0, 2.0] arrowEdgeOpacity: 0.2, // [0.0, 1.0] arrowOpacity: 0.9, // [0.0, 1.0] arrowOffsetY: 0.46, // [-1.0, 1.0] arrowThickness: 0.23, // Multiplier [0.0, 5.0]. Only in 3D arrowWidth: 0.65, // [0.2, 5.0] distance: false, distanceColor: \"#ffffff\", distanceIs3d: false, distancePosition: 1.0, // [0.5, 2.0] distanceOpacity: 1.0, // [0.0, 1.0] distanceSize: 1.0, // [0.5, 4.0] fade: 0.5, // [0.1, 1.0] is3d: false, // Refer to arrow opacity: 0.4, // [0.0, 1.0] scale: 1.0, // [0.2, 2.0] size: 1.0, // [0.5, 4.0] smoothing: 0.05, // [0.0, 1.0] threshold: 0.2 // [0.0, 1.0] } Text Box The tool_id is textBox . Text text: 'Insert Text' Position position: { x: 0.45, y: 0.45 } // Normalized: screen-space or field-space if 'is3d' is enabled. Options options: { width: 0.1, height: 0.1, size: 1.0, // [0.5, 4.0] rotation: 0.0, // [-Math.PI, Math.PI] color: \"#ffffff\", opacity: 1.0, // [0.0, 1.0] align: 'center', background: false, backgroundColor: \"#000000\", backgroundOpacity: 0.5, // [0.0, 1.0] is3d: false } Image The tool_id is image . Image will be downloaded locally and placed in the workspace path. URL url: 'https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_92x30dp.png' Position position: { x: 0.25, y: 0.25 } // Normalized: screen-space or field-space if 'is3d' is enabled. Scale scale: { x: 0.5, y: 0.5 } // Normalized: screen-space or field-space if 'is3d' is enabled. Options options: { rotation: 0.0, // [-Math.PI, Math.PI] opacity: 1.0, // [0.0, 1.0] is3d: false } Pause The tool_id is pause . Pause Time pause_time: 5000 // Milliseconds Chroma-Key The tool_id is chromaKey . It'll be computed on each clip created. Options should be set according to the scene, so if it remains similar during a game, maybe you want to adapt these values from a sample clip in Play and use them in all chroma-key events. Otherwise, you should not pass any option, use default values and fit them in each clip if needed. Since the order in which visualizations added declared in the event is preserved when they are imported in play, the Chroma-key tool should be added in the specific desired position. For example, if you want to add shape in the field and an arrow, but chroma key only to have an effect on the shape on the field, the order in the event should be: shape - chroma key - arrow. Options options: { threshold : 0.01, // [0.0, 1.0] smoothing : 0.1 // [0.0, 1.0] }","title":"Visualizations"},{"location":"visualizations/#visualizations-types-and-settings","text":"This section describes all the possible visualizations that can be added to an event, as well as the API to be imported into Play. For each one of these possibilities, there is a dataclass defined in visualizations.py so that they can be easily added from the code.","title":"Visualizations types and settings"},{"location":"visualizations/#fields-common-to-all-visualizations","text":"The following attributes have to be defined for each tool. Annotations' order matters, they will be created and displayed in the same order they are declared, first annotation will be rendered at the bottom/background. { start_time : 1040, // Milliseconds end_time : 2130, // Milliseconds tool_id : 'players', // The ID of the tool ... // Each tool could have other mandatory attributes options : {}, // Optional object attribute for the tool version : 2 // Which version of API it's the viz compatible with }","title":"Fields common to all visualizations"},{"location":"visualizations/#tools","text":"This is a list of all the tools that is possible to add as annotations. Each option of each tool is optional. If you don't include some of them, default value will be used. The options attribute and the children of it are optional. If you don't include some or all of them, default values will be used","title":"Tools"},{"location":"visualizations/#players","text":"The tool_id is players . Players players: ['P001', 'P002'] Options options: { id : false, speed : false, size : 1.0, // [0.2, 2.5] color : '#000000', boxPositionDown : false, spotlight : false, spotlightSize : 0.5, // Multiplier [0.2, 4.0] spotlightColor : '#FFFFFF', spotlightOpacity : 0.43, // [0.0, 1.0] spotlightHeight : 2.0, // [0.1, 10.0] ringSize : 0.73, ringBorder : false, ringBorderColor : '#FFFFFF', ringFill : false, ringFillColor : '#DC3322', is3d : false }","title":"Players"},{"location":"visualizations/#trails","text":"The tool_id is trails . Players players: ['P001', 'P002'] Options options: { color: '#0062ad', continuous: true, dotted: false, dashSize: 1.0, // Multiplier [0.2, 2.5]. Only Dotted is3d: false, ringBorder: true, offsetOpacity: 0.26, // [0.0, 1.0] opacity: 1.0, // [0.0, 1.0] ringBorderColor: \"#ffffff\", ringFill: true, ringFillColor: '#009cdd', ringSize: 1.0, // Multiplier [0.6, 4.0] seconds: 5.0, // [1.0, 99.0] thickness: 0.1, // Multiplier [0.1, 5.0]. Only in 3D width: 0.24 // Multiplier [0.1, 2.0] }","title":"Trails"},{"location":"visualizations/#future-trails","text":"The tool_id is futureTrails . Players players: ['P001', 'P002'] Options options: { color: '#ff9e2d', continuous: true, dashSize: 0.6, // Multiplier [0.2, 2.5]. Only Dotted dotted: false, is3d: false, offsetOpacity: 0.05, // [0.0, 1.0] opacity: 1.0, // [0.0, 1.0] ringBorder: true, ringBorderColor: \"#ffffff\", ringFill: true, ringFillColor: '#ffdc3a', ringSize: 1.0, // Multiplier [0.6, 4.0] seconds: 5.0, // [1.0, 99.0] thickness: 0.23, // Multiplier [0.1, 5.0]. Only in 3D width: 0.29 // Multiplier [0.1, 2.0] }","title":"Future Trails"},{"location":"visualizations/#magnifiers","text":"The tool_id is magnifiers . Players players: ['P001', 'P002'] Options options: { color: '#ffffff', zoom : 1.0, // [0.2, 1.5], size : 1.0 // [0.5, 1.5] }","title":"Magnifiers"},{"location":"visualizations/#measurer","text":"The tool_id is measurer . Players players: ['P001', 'P002'] Options options: { borderColor: '#dc3322', borderEdgeOpacity: 0.4, // [0.0, 1.0] borderOpacity: 0.9, // [0.0, 1.0] closed: false, continuous: true, dashSize: 1.45, // Multiplier [0.2, 2.5]. Only Dotted distance: true, distanceColor: '#ffffff', distanceIs3d: false, distancePosition: 0.92, // Multiplier [0.5, 2.0] distanceOpacity: 1.0, // [0.0, 1.0] distanceSize: 1.01, // Multiplier [0.5, 1.5] dotted: false, fillColor: '#dc3322', Only Closed fillOpacity: 0.42, // [0.0, 1.0] is3d: false, ringBorder: true, ringBorderColor: '#ffffff', ringFill: true, ringFillColor: '#dc3322', ringSize: 0.91, // Multiplier [0.6, 4.0] thickness: 0.13, // Multiplier [0.0, 5.0]. Only in 3D width: 0.23, // Multiplier [0.15, 2.0] }","title":"Measurer"},{"location":"visualizations/#team-size","text":"The tool_id is teamSize . Team team: 'T001' Line line: 'width' // Values: 'width' or 'length' Options options: { continuous: true, dotted: false, color: '#683391', x: 0.0, y: 0.0, width: 0.23, // [0.1, 5.0] edgeOpacity: 0.0, // [0.0, 1.0] opacity: 1.0, // [0.0, 1.0] thickness: 0.22, // Multiplier [0.0, 5.0]. Only in 3D dashSize: 0.6, // Multiplier [0.2, 2.5]. Only Dotted distance: true, distanceColor: '#ffffff', distancePosition: 1.12, // [0.5, 2.0] distanceOpacity: 1.0, // Multiplier [0.0, 1.0] distanceSize: 1.3, // Multiplier [0.5, 1.5] distanceIs3d: false, is3d: false }","title":"Team Size"},{"location":"visualizations/#tactical-lines","text":"The tool_id is tacticalLines . Team team: 'T001' Line line: 'defenders' // Values: 'defenders', 'midfielders' or 'strikers' Options options: { borderColor: \"#ffffff\", borderEdgeOpacity: 0.3, // [0.1, 1.0] borderOpacity: 1.0, // [0.0, 1.0] fillColor: \"#ffffff\", fillOpacity: 0.4, // [0.0, 1.0] closed: false, // Only used when line is 'midfielders' width: 0.23, // [0.1, 2.0] thickness: 0.3, // Multiplier [0.0, 5.0]. Only in 3D dashSize: 1.0, // Multiplier [0.2, 2.5]. Only Dotted continuous: true, dotted: false, is3d: false, ringBorder: true, ringBorderColor: \"#ffffff\", ringFill: true, ringFillColor: \"#ffffff\", ringSize: 0.6, // [0.6, 4.0] distance: true, distanceColor: \"#ffffff\", distancePosition: 0.5, // Multiplier [0.5, 2.0] distanceOpacity: 1.0, // [0.0, 1.0] distanceSize: 0.73, // [0.5, 1.5] distanceIs3d: false }","title":"Tactical Lines"},{"location":"visualizations/#line-3d","text":"The tool_id is line3d . Points // Normalized points: { start : { x: 0.0, y: 0.0 }, end : { x: 0.0, y: 0.0 } } Options options: { arrowheadWidth: 1.5, // [0.99, 2.0] color: '#ff4f43', continuous: true, curvature: 0.0, // [-1.0, 1.0] dashSize: 0.4, // Multiplier [0.2, 2.5] distance: false, distanceColor: '#ffffff', distancePosition: 0.92, // Multiplier [0.5, 2.0] distanceOpacity: 1.0, // [0.0, 1.0] distanceSize: 1.01, // Multiplier [0.5, 4.0] distanceIs3d: false, dotted: false, dynamic: false, edgeOpacity: 0.2, // [0.0, 1.0] opacity: 0.9, // [0.0, 1.0] height: 0.075, // [0.0, 0.15] heightCenter: 0.0, // [-1.0, 1.0] is3d: false, pinned: false, thickness: 0.15, // Multiplier [0.0, 5.0] width: 0.5 // [0.1, 5.0] }","title":"Line 3D"},{"location":"visualizations/#freehand","text":"The tool_id is freehand . Points // Normalized: screen-space or field-space if 'is3d' is enabled. points: [ { x: 0.0, y: 0.0 }, ..., { x: 0.0, y: 0.0 } ] Options options: { color: '#9edd34', arrowheadWidth: 3.0, // [0.99, 5.0] continuous: true, dashSize: 0.5, // Multiplier [0.2, 2.0]. Only Dotted dotted: false, offsetOpacity: 0.2, // [0.0, 1.0] opacity: 0.9, // [0.0, 1.0] is3d: false, pinned: false, thickness: 0.07, // Multiplier [0.0, 5.0]. Only in 3D width: 0.2 // [0.1, 0.2] }","title":"Freehand"},{"location":"visualizations/#circle","text":"The tool_id is circle . Center and Radius // Normalized: screen-space or field-space if 'is3d' is enabled. center: { x: 0.0, y: 0.0 }, radius: { x: 0.1, y: 0.1 } Options options: { borderColor: '#b3b3b3', borderOpacity: 1.0, // [0.0, 1.0] fillColor: '#ffdc3a', fillOpacity: 0.26, // [0.0, 1.0] fillSolid: true, fillPattern: false, is3d: false, pinned: false, thickness: 0.5, // Multiplier [0.0, 5.0]. Only in 3D width: 0.62 // [0.0, 3.0] }","title":"Circle"},{"location":"visualizations/#shape","text":"The tool_id is shape . Points // Normalized: screen-space or field-space if 'is3d' is enabled. points: [ { x: 0.0, y: 0.0 }, ..., { x: 0.0, y: 0.0 } ] Options options: { borderColor: '#0062ad', borderOpacity: 1.0, // [0.1, 1.0] borderContinuous: false, borderDotted: true, closed: false, dashSize: 0.6, // Multiplier [0.5, 1.5]. Only Dotted distance: true, distanceColor: \"#ffffff\", distancePosition: 1.0, // Multiplier [0.5, 2.0] distanceOpacity: 1.0, // [0.0, 1.0] distanceSize: 1.0, // [0.5, 1.5] distanceIs3d: false, fillColor: '#0062ad', fillOpacity: 0.25, // [0.0, 1.0] fillSolid: true, fillPattern: false, is3d: false, pinned: false, thickness: 0.1, // Multiplier [0.0, 5.0]. Only in 3D width: 0.15 // [0.0, 2.0] }","title":"Shape"},{"location":"visualizations/#arrow","text":"The tool_id is arrow . Points // Normalized: screen-space or field-space if 'is3d' is enabled. points: { start : { x: 0.0, y: 0.0 }, end : { x: 0.0, y: 0.0 } } Options options: { arrowheadWidth: 1.5, // [0.99, 2.0] color: '#ff4f43', continuous: true, curvature: 0.0, // Multiplier [-1.0, 1.0]. Only in 3D dashSize: 0.4, // Multiplier [0.2, 2.5]. Only Dotted distance: false, distanceColor: \"#ffffff\", distancePosition: 0.92, // Multiplier [0.5, 2.0] distanceOpacity: 1.0, // [0.0, 1.0] distanceSize: 1.01, // [0.5, 4.0] distanceIs3d: false, dotted: false, dynamic: false, edgeOpacity: 0.2, // [0.0, 1.0] opacity: 0.9, // [0.0, 1.0] height: 0.0, // [0.0, 0.15] heightCenter: 0.0, // [-1.0, 1.0] is3d: false, pinned: false, thickness: 0.15, // Multiplier [0.0, 5.0]. Only in 3D width: 0.5 // [0.1, 5.0] }","title":"Arrow"},{"location":"visualizations/#dragger","text":"The tool_id is dragger . Points // Normalized: screen-space only. Flag 'is3d' is only applied to arrow. points: { start : { x: 0.0, y: 0.0 }, end : { x: 0.0, y: 0.0 } } Options options: { arrowColor: '#ffdc3a', arrowContinuous: true, arrowDashSize: 0.6, // Multiplier [0.6, 2.5]. Only arrowDotted arrowDotted: false, arrowDynamic: false, arrowheadWidth: 2.0, // [0.0, 2.0] arrowEdgeOpacity: 0.2, // [0.0, 1.0] arrowOpacity: 0.9, // [0.0, 1.0] arrowOffsetY: 0.46, // [-1.0, 1.0] arrowThickness: 0.23, // Multiplier [0.0, 5.0]. Only in 3D arrowWidth: 0.65, // [0.2, 5.0] distance: false, distanceColor: \"#ffffff\", distanceIs3d: false, distancePosition: 1.0, // [0.5, 2.0] distanceOpacity: 1.0, // [0.0, 1.0] distanceSize: 1.0, // [0.5, 4.0] fade: 0.5, // [0.1, 1.0] is3d: false, // Refer to arrow opacity: 0.4, // [0.0, 1.0] scale: 1.0, // [0.2, 2.0] size: 1.0, // [0.5, 4.0] smoothing: 0.05, // [0.0, 1.0] threshold: 0.2 // [0.0, 1.0] }","title":"Dragger"},{"location":"visualizations/#text-box","text":"The tool_id is textBox . Text text: 'Insert Text' Position position: { x: 0.45, y: 0.45 } // Normalized: screen-space or field-space if 'is3d' is enabled. Options options: { width: 0.1, height: 0.1, size: 1.0, // [0.5, 4.0] rotation: 0.0, // [-Math.PI, Math.PI] color: \"#ffffff\", opacity: 1.0, // [0.0, 1.0] align: 'center', background: false, backgroundColor: \"#000000\", backgroundOpacity: 0.5, // [0.0, 1.0] is3d: false }","title":"Text Box"},{"location":"visualizations/#image","text":"The tool_id is image . Image will be downloaded locally and placed in the workspace path. URL url: 'https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_92x30dp.png' Position position: { x: 0.25, y: 0.25 } // Normalized: screen-space or field-space if 'is3d' is enabled. Scale scale: { x: 0.5, y: 0.5 } // Normalized: screen-space or field-space if 'is3d' is enabled. Options options: { rotation: 0.0, // [-Math.PI, Math.PI] opacity: 1.0, // [0.0, 1.0] is3d: false }","title":"Image"},{"location":"visualizations/#pause","text":"The tool_id is pause . Pause Time pause_time: 5000 // Milliseconds","title":"Pause"},{"location":"visualizations/#chroma-key","text":"The tool_id is chromaKey . It'll be computed on each clip created. Options should be set according to the scene, so if it remains similar during a game, maybe you want to adapt these values from a sample clip in Play and use them in all chroma-key events. Otherwise, you should not pass any option, use default values and fit them in each clip if needed. Since the order in which visualizations added declared in the event is preserved when they are imported in play, the Chroma-key tool should be added in the specific desired position. For example, if you want to add shape in the field and an arrow, but chroma key only to have an effect on the shape on the field, the order in the event should be: shape - chroma key - arrow. Options options: { threshold : 0.01, // [0.0, 1.0] smoothing : 0.1 // [0.0, 1.0] }","title":"Chroma-Key"},{"location":"examples/example-pattern/","text":"As an example, the below code defines a pattern that will look for all passes into the opponents box. Moreover to be imported into Metrica Play, it will add an arrow and a 2s pause in the video at the moment of the pass, and will add an arrow to the 2D field indicating start and end position of the pass. class PassesIntoTheBox(Pattern): def __init__( self, game_dataset: GameDataset, name: str, code: str, in_time: int = 0, out_time: int = 0, parameters: dict = None, ): super().__init__( name, code, in_time, out_time, parameters, game_dataset ) def run(self) -> List[PatternEvent]: passes_into_the_box = ( self.game_dataset.events.type(\"PASS\") .into(Zones.OPPONENT_BOX) .result(\"COMPLETE\") ) return [ self.build_pattern_event(event_row) for i, event_row in passes_into_the_box.iterrows() ] def build_pattern_event(self, event_row) -> PatternEvent: pattern_event = self.from_event(event_row) pattern_event.add_arrow(event_row) pattern_event.add_pause(pause_time=2000) return pattern_event With this configuration: { \"include\": true, \"name\": \"Passes into the box\", \"code\": \"MET_003\", \"pattern_class\": \"PassesIntoTheBox\", \"parameters\": null, \"in_time\": 2, \"out_time\": 2 } Produces this output when imported into Metrica Play:","title":"Example pattern"},{"location":"examples/game_dataset/","text":"/*! * * IPython notebook * */ /* CSS font colors for translated ANSI escape sequences */ /* The color values are a mix of http://www.xcolors.net/dl/baskerville-ivorylight and http://www.xcolors.net/dl/euphrasia */ .ansi-black-fg { color: #3E424D; } .ansi-black-bg { background-color: #3E424D; } .ansi-black-intense-fg { color: #282C36; } .ansi-black-intense-bg { background-color: #282C36; } .ansi-red-fg { color: #E75C58; } .ansi-red-bg { background-color: #E75C58; } .ansi-red-intense-fg { color: #B22B31; } .ansi-red-intense-bg { background-color: #B22B31; } .ansi-green-fg { color: #00A250; } .ansi-green-bg { background-color: #00A250; } .ansi-green-intense-fg { color: #007427; } .ansi-green-intense-bg { background-color: #007427; } .ansi-yellow-fg { color: #DDB62B; } .ansi-yellow-bg { background-color: #DDB62B; } .ansi-yellow-intense-fg { color: #B27D12; } .ansi-yellow-intense-bg { background-color: #B27D12; } .ansi-blue-fg { color: #208FFB; } .ansi-blue-bg { background-color: #208FFB; } .ansi-blue-intense-fg { color: #0065CA; } .ansi-blue-intense-bg { background-color: #0065CA; } .ansi-magenta-fg { color: #D160C4; } .ansi-magenta-bg { background-color: #D160C4; } .ansi-magenta-intense-fg { color: #A03196; } .ansi-magenta-intense-bg { background-color: #A03196; } .ansi-cyan-fg { color: #60C6C8; } .ansi-cyan-bg { background-color: #60C6C8; } .ansi-cyan-intense-fg { color: #258F8F; } .ansi-cyan-intense-bg { background-color: #258F8F; } .ansi-white-fg { color: #C5C1B4; } .ansi-white-bg { background-color: #C5C1B4; } .ansi-white-intense-fg { color: #A1A6B2; } .ansi-white-intense-bg { background-color: #A1A6B2; } .ansi-default-inverse-fg { color: #FFFFFF; } .ansi-default-inverse-bg { background-color: #000000; } .ansi-bold { font-weight: bold; } .ansi-underline { text-decoration: underline; } /* The following styles are deprecated an will be removed in a future version */ .ansibold { font-weight: bold; } .ansi-inverse { outline: 0.5px dotted; } /* use dark versions for foreground, to improve visibility */ .ansiblack { color: black; } .ansired { color: darkred; } .ansigreen { color: darkgreen; } .ansiyellow { color: #c4a000; } .ansiblue { color: darkblue; } .ansipurple { color: darkviolet; } .ansicyan { color: steelblue; } .ansigray { color: gray; } /* and light for background, for the same reason */ .ansibgblack { background-color: black; } .ansibgred { background-color: red; } .ansibggreen { background-color: green; } .ansibgyellow { background-color: yellow; } .ansibgblue { background-color: blue; } .ansibgpurple { background-color: magenta; } .ansibgcyan { background-color: cyan; } .ansibggray { background-color: gray; } div.cell { /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; border-radius: 2px; box-sizing: border-box; -moz-box-sizing: border-box; -webkit-box-sizing: border-box; border-width: 1px; border-style: solid; border-color: transparent; width: 100%; padding: 5px; /* This acts as a spacer between cells, that is outside the border */ margin: 0px; outline: none; position: relative; overflow: visible; } div.cell:before { position: absolute; display: block; top: -1px; left: -1px; width: 5px; height: calc(100% + 2px); content: ''; background: transparent; } div.cell.jupyter-soft-selected { border-left-color: #E3F2FD; border-left-width: 1px; padding-left: 5px; border-right-color: #E3F2FD; border-right-width: 1px; background: #E3F2FD; } @media print { div.cell.jupyter-soft-selected { border-color: transparent; } } div.cell.selected, div.cell.selected.jupyter-soft-selected { border-color: #ababab; } div.cell.selected:before, div.cell.selected.jupyter-soft-selected:before { position: absolute; display: block; top: -1px; left: -1px; width: 5px; height: calc(100% + 2px); content: ''; background: #42A5F5; } @media print { div.cell.selected, div.cell.selected.jupyter-soft-selected { border-color: transparent; } } .edit_mode div.cell.selected { border-color: #66BB6A; } .edit_mode div.cell.selected:before { position: absolute; display: block; top: -1px; left: -1px; width: 5px; height: calc(100% + 2px); content: ''; background: #66BB6A; } @media print { .edit_mode div.cell.selected { border-color: transparent; } } .prompt { /* This needs to be wide enough for 3 digit prompt numbers: In[100]: */ min-width: 14ex; /* This padding is tuned to match the padding on the CodeMirror editor. */ padding: 0.4em; margin: 0px; font-family: monospace; text-align: right; /* This has to match that of the the CodeMirror class line-height below */ line-height: 1.21429em; /* Don't highlight prompt number selection */ -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; /* Use default cursor */ cursor: default; } @media (max-width: 540px) { .prompt { text-align: left; } } div.inner_cell { min-width: 0; /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; /* Old browsers */ -webkit-box-flex: 1; -moz-box-flex: 1; box-flex: 1; /* Modern browsers */ flex: 1; } /* input_area and input_prompt must match in top border and margin for alignment */ div.input_area { border: 1px solid #cfcfcf; border-radius: 2px; background: #f7f7f7; line-height: 1.21429em; } /* This is needed so that empty prompt areas can collapse to zero height when there is no content in the output_subarea and the prompt. The main purpose of this is to make sure that empty JavaScript output_subareas have no height. */ div.prompt:empty { padding-top: 0; padding-bottom: 0; } div.unrecognized_cell { padding: 5px 5px 5px 0px; /* Old browsers */ display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: horizontal; -moz-box-align: stretch; display: box; box-orient: horizontal; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: row; align-items: stretch; } div.unrecognized_cell .inner_cell { border-radius: 2px; padding: 5px; font-weight: bold; color: red; border: 1px solid #cfcfcf; background: #eaeaea; } div.unrecognized_cell .inner_cell a { color: inherit; text-decoration: none; } div.unrecognized_cell .inner_cell a:hover { color: inherit; text-decoration: none; } @media (max-width: 540px) { div.unrecognized_cell > div.prompt { display: none; } } div.code_cell { /* avoid page breaking on code cells when printing */ } @media print { div.code_cell { page-break-inside: avoid; } } /* any special styling for code cells that are currently running goes here */ div.input { page-break-inside: avoid; /* Old browsers */ display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: horizontal; -moz-box-align: stretch; display: box; box-orient: horizontal; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: row; align-items: stretch; } @media (max-width: 540px) { div.input { /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; } } /* input_area and input_prompt must match in top border and margin for alignment */ div.input_prompt { color: #303F9F; border-top: 1px solid transparent; } div.input_area > div.highlight { margin: 0.4em; border: none; padding: 0px; background-color: transparent; } div.input_area > div.highlight > pre { margin: 0px; border: none; padding: 0px; background-color: transparent; } /* The following gets added to the <head> if it is detected that the user has a * monospace font with inconsistent normal/bold/italic height. See * notebookmain.js. Such fonts will have keywords vertically offset with * respect to the rest of the text. The user should select a better font. * See: https://github.com/ipython/ipython/issues/1503 * * .CodeMirror span { * vertical-align: bottom; * } */ .CodeMirror { line-height: 1.21429em; /* Changed from 1em to our global default */ font-size: 14px; height: auto; /* Changed to auto to autogrow */ background: none; /* Changed from white to allow our bg to show through */ } .CodeMirror-scroll { /* The CodeMirror docs are a bit fuzzy on if overflow-y should be hidden or visible.*/ /* We have found that if it is visible, vertical scrollbars appear with font size changes.*/ overflow-y: hidden; overflow-x: auto; } .CodeMirror-lines { /* In CM2, this used to be 0.4em, but in CM3 it went to 4px. We need the em value because */ /* we have set a different line-height and want this to scale with that. */ /* Note that this should set vertical padding only, since CodeMirror assumes that horizontal padding will be set on CodeMirror pre */ padding: 0.4em 0; } .CodeMirror-linenumber { padding: 0 8px 0 4px; } .CodeMirror-gutters { border-bottom-left-radius: 2px; border-top-left-radius: 2px; } .CodeMirror pre { /* In CM3 this went to 4px from 0 in CM2. This sets horizontal padding only, use .CodeMirror-lines for vertical */ padding: 0 0.4em; border: 0; border-radius: 0; } .CodeMirror-cursor { border-left: 1.4px solid black; } @media screen and (min-width: 2138px) and (max-width: 4319px) { .CodeMirror-cursor { border-left: 2px solid black; } } @media screen and (min-width: 4320px) { .CodeMirror-cursor { border-left: 4px solid black; } } /* Original style from softwaremaniacs.org (c) Ivan Sagalaev <Maniac@SoftwareManiacs.Org> Adapted from GitHub theme */ .highlight-base { color: #000; } .highlight-variable { color: #000; } .highlight-variable-2 { color: #1a1a1a; } .highlight-variable-3 { color: #333333; } .highlight-string { color: #BA2121; } .highlight-comment { color: #408080; font-style: italic; } .highlight-number { color: #080; } .highlight-atom { color: #88F; } .highlight-keyword { color: #008000; font-weight: bold; } .highlight-builtin { color: #008000; } .highlight-error { color: #f00; } .highlight-operator { color: #AA22FF; font-weight: bold; } .highlight-meta { color: #AA22FF; } /* previously not defined, copying from default codemirror */ .highlight-def { color: #00f; } .highlight-string-2 { color: #f50; } .highlight-qualifier { color: #555; } .highlight-bracket { color: #997; } .highlight-tag { color: #170; } .highlight-attribute { color: #00c; } .highlight-header { color: blue; } .highlight-quote { color: #090; } .highlight-link { color: #00c; } /* apply the same style to codemirror */ .cm-s-ipython span.cm-keyword { color: #008000; font-weight: bold; } .cm-s-ipython span.cm-atom { color: #88F; } .cm-s-ipython span.cm-number { color: #080; } .cm-s-ipython span.cm-def { color: #00f; } .cm-s-ipython span.cm-variable { color: #000; } .cm-s-ipython span.cm-operator { color: #AA22FF; font-weight: bold; } .cm-s-ipython span.cm-variable-2 { color: #1a1a1a; } .cm-s-ipython span.cm-variable-3 { color: #333333; } .cm-s-ipython span.cm-comment { color: #408080; font-style: italic; } .cm-s-ipython span.cm-string { color: #BA2121; } .cm-s-ipython span.cm-string-2 { color: #f50; } .cm-s-ipython span.cm-meta { color: #AA22FF; } .cm-s-ipython span.cm-qualifier { color: #555; } .cm-s-ipython span.cm-builtin { color: #008000; } .cm-s-ipython span.cm-bracket { color: #997; } .cm-s-ipython span.cm-tag { color: #170; } .cm-s-ipython span.cm-attribute { color: #00c; } .cm-s-ipython span.cm-header { color: blue; } .cm-s-ipython span.cm-quote { color: #090; } .cm-s-ipython span.cm-link { color: #00c; } .cm-s-ipython span.cm-error { color: #f00; } .cm-s-ipython span.cm-tab { background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAMCAYAAAAkuj5RAAAAAXNSR0IArs4c6QAAAGFJREFUSMft1LsRQFAQheHPowAKoACx3IgEKtaEHujDjORSgWTH/ZOdnZOcM/sgk/kFFWY0qV8foQwS4MKBCS3qR6ixBJvElOobYAtivseIE120FaowJPN75GMu8j/LfMwNjh4HUpwg4LUAAAAASUVORK5CYII=); background-position: right; background-repeat: no-repeat; } div.output_wrapper { /* this position must be relative to enable descendents to be absolute within it */ position: relative; /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; z-index: 1; } /* class for the output area when it should be height-limited */ div.output_scroll { /* ideally, this would be max-height, but FF barfs all over that */ height: 24em; /* FF needs this *and the wrapper* to specify full width, or it will shrinkwrap */ width: 100%; overflow: auto; border-radius: 2px; -webkit-box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.8); box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.8); display: block; } /* output div while it is collapsed */ div.output_collapsed { margin: 0px; padding: 0px; /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; } div.out_prompt_overlay { height: 100%; padding: 0px 0.4em; position: absolute; border-radius: 2px; } div.out_prompt_overlay:hover { /* use inner shadow to get border that is computed the same on WebKit/FF */ -webkit-box-shadow: inset 0 0 1px #000; box-shadow: inset 0 0 1px #000; background: rgba(240, 240, 240, 0.5); } div.output_prompt { color: #D84315; } /* This class is the outer container of all output sections. */ div.output_area { padding: 0px; page-break-inside: avoid; /* Old browsers */ display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: horizontal; -moz-box-align: stretch; display: box; box-orient: horizontal; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: row; align-items: stretch; } div.output_area .MathJax_Display { text-align: left !important; } div.output_area div.output_area div.output_area img, div.output_area svg { max-width: 100%; height: auto; } div.output_area img.unconfined, div.output_area svg.unconfined { max-width: none; } div.output_area .mglyph > img { max-width: none; } /* This is needed to protect the pre formating from global settings such as that of bootstrap */ .output { /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; } @media (max-width: 540px) { div.output_area { /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; } } div.output_area pre { margin: 0; padding: 1px 0 1px 0; border: 0; vertical-align: baseline; color: black; background-color: transparent; border-radius: 0; } /* This class is for the output subarea inside the output_area and after the prompt div. */ div.output_subarea { overflow-x: auto; padding: 0.4em; /* Old browsers */ -webkit-box-flex: 1; -moz-box-flex: 1; box-flex: 1; /* Modern browsers */ flex: 1; max-width: calc(100% - 14ex); } div.output_scroll div.output_subarea { overflow-x: visible; } /* The rest of the output_* classes are for special styling of the different output types */ /* all text output has this class: */ div.output_text { text-align: left; color: #000; /* This has to match that of the the CodeMirror class line-height below */ line-height: 1.21429em; } /* stdout/stderr are 'text' as well as 'stream', but execute_result/error are *not* streams */ div.output_stderr { background: #fdd; /* very light red background for stderr */ } div.output_latex { text-align: left; } /* Empty output_javascript divs should have no height */ div.output_javascript:empty { padding: 0; } .js-error { color: darkred; } /* raw_input styles */ div.raw_input_container { line-height: 1.21429em; padding-top: 5px; } pre.raw_input_prompt { /* nothing needed here. */ } input.raw_input { font-family: monospace; font-size: inherit; color: inherit; width: auto; /* make sure input baseline aligns with prompt */ vertical-align: baseline; /* padding + margin = 0.5em between prompt and cursor */ padding: 0em 0.25em; margin: 0em 0.25em; } input.raw_input:focus { box-shadow: none; } p.p-space { margin-bottom: 10px; } div.output_unrecognized { padding: 5px; font-weight: bold; color: red; } div.output_unrecognized a { color: inherit; text-decoration: none; } div.output_unrecognized a:hover { color: inherit; text-decoration: none; } .rendered_html { color: #000; /* any extras will just be numbers: */ } .rendered_html :link { text-decoration: underline; } .rendered_html :visited { text-decoration: underline; } .rendered_html h1:first-child { margin-top: 0.538em; } .rendered_html h2:first-child { margin-top: 0.636em; } .rendered_html h3:first-child { margin-top: 0.777em; } .rendered_html h4:first-child { margin-top: 1em; } .rendered_html h5:first-child { margin-top: 1em; } .rendered_html h6:first-child { margin-top: 1em; } .rendered_html ul:not(.list-inline), .rendered_html ol:not(.list-inline) { padding-left: 2em; } .rendered_html * + ul { margin-top: 1em; } .rendered_html * + ol { margin-top: 1em; } .rendered_html pre, .rendered_html tr, .rendered_html th, .rendered_html tbody tr:nth-child(odd) { background: #f5f5f5; } .rendered_html tbody tr:hover { background: rgba(66, 165, 245, 0.2); } .rendered_html * + table { margin-top: 1em; } .rendered_html * + p { margin-top: 1em; } .rendered_html * + img { margin-top: 1em; } .rendered_html img, .rendered_html img.unconfined, .rendered_html * + .alert { margin-top: 1em; } [dir=\"rtl\"] div.text_cell { /* Old browsers */ display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: horizontal; -moz-box-align: stretch; display: box; box-orient: horizontal; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: row; align-items: stretch; } @media (max-width: 540px) { div.text_cell > div.prompt { display: none; } } div.text_cell_render { /*font-family: \"Helvetica Neue\", Arial, Helvetica, Geneva, sans-serif;*/ outline: none; resize: none; width: inherit; border-style: none; padding: 0.5em 0.5em 0.5em 0.4em; color: #000; box-sizing: border-box; -moz-box-sizing: border-box; -webkit-box-sizing: border-box; } a.anchor-link:link { text-decoration: none; padding: 0px 20px; visibility: hidden; } h1:hover .anchor-link, h2:hover .anchor-link, h3:hover .anchor-link, h4:hover .anchor-link, h5:hover .anchor-link, h6:hover .anchor-link { visibility: visible; } .text_cell.rendered .input_area { display: none; } .text_cell.rendered .text_cell.rendered .rendered_html tr, .text_cell.rendered .rendered_html th, .text_cell.rendered .text_cell.unrendered .text_cell_render { display: none; } .text_cell .dropzone .input_area { border: 2px dashed #bababa; margin: -1px; } .cm-header-1, .cm-header-2, .cm-header-3, .cm-header-4, .cm-header-5, .cm-header-6 { font-weight: bold; font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif; } .cm-header-1 { font-size: 185.7%; } .cm-header-2 { font-size: 157.1%; } .cm-header-3 { font-size: 128.6%; } .cm-header-4 { font-size: 110%; } .cm-header-5 { font-size: 100%; font-style: italic; } .cm-header-6 { font-size: 100%; font-style: italic; } pre { line-height: 125%; } td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; } span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; } td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; } span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; } .highlight-ipynb .hll { background-color: #ffffcc } .highlight-ipynb { background: #f8f8f8; } .highlight-ipynb .c { color: #3D7B7B; font-style: italic } /* Comment */ .highlight-ipynb .err { border: 1px solid #FF0000 } /* Error */ .highlight-ipynb .k { color: #008000; font-weight: bold } /* Keyword */ .highlight-ipynb .o { color: #666666 } /* Operator */ .highlight-ipynb .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */ .highlight-ipynb .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */ .highlight-ipynb .cp { color: #9C6500 } /* Comment.Preproc */ .highlight-ipynb .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */ .highlight-ipynb .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */ .highlight-ipynb .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */ .highlight-ipynb .gd { color: #A00000 } /* Generic.Deleted */ .highlight-ipynb .ge { font-style: italic } /* Generic.Emph */ .highlight-ipynb .gr { color: #E40000 } /* Generic.Error */ .highlight-ipynb .gh { color: #000080; font-weight: bold } /* Generic.Heading */ .highlight-ipynb .gi { color: #008400 } /* Generic.Inserted */ .highlight-ipynb .go { color: #717171 } /* Generic.Output */ .highlight-ipynb .gp { color: #000080; font-weight: bold } /* Generic.Prompt */ .highlight-ipynb .gs { font-weight: bold } /* Generic.Strong */ .highlight-ipynb .gu { color: #800080; font-weight: bold } /* Generic.Subheading */ .highlight-ipynb .gt { color: #0044DD } /* Generic.Traceback */ .highlight-ipynb .kc { color: #008000; font-weight: bold } /* Keyword.Constant */ .highlight-ipynb .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */ .highlight-ipynb .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */ .highlight-ipynb .kp { color: #008000 } /* Keyword.Pseudo */ .highlight-ipynb .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */ .highlight-ipynb .kt { color: #B00040 } /* Keyword.Type */ .highlight-ipynb .m { color: #666666 } /* Literal.Number */ .highlight-ipynb .s { color: #BA2121 } /* Literal.String */ .highlight-ipynb .na { color: #687822 } /* Name.Attribute */ .highlight-ipynb .nb { color: #008000 } /* Name.Builtin */ .highlight-ipynb .nc { color: #0000FF; font-weight: bold } /* Name.Class */ .highlight-ipynb .no { color: #880000 } /* Name.Constant */ .highlight-ipynb .nd { color: #AA22FF } /* Name.Decorator */ .highlight-ipynb .ni { color: #717171; font-weight: bold } /* Name.Entity */ .highlight-ipynb .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */ .highlight-ipynb .nf { color: #0000FF } /* Name.Function */ .highlight-ipynb .nl { color: #767600 } /* Name.Label */ .highlight-ipynb .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */ .highlight-ipynb .nt { color: #008000; font-weight: bold } /* Name.Tag */ .highlight-ipynb .nv { color: #19177C } /* Name.Variable */ .highlight-ipynb .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */ .highlight-ipynb .w { color: #bbbbbb } /* Text.Whitespace */ .highlight-ipynb .mb { color: #666666 } /* Literal.Number.Bin */ .highlight-ipynb .mf { color: #666666 } /* Literal.Number.Float */ .highlight-ipynb .mh { color: #666666 } /* Literal.Number.Hex */ .highlight-ipynb .mi { color: #666666 } /* Literal.Number.Integer */ .highlight-ipynb .mo { color: #666666 } /* Literal.Number.Oct */ .highlight-ipynb .sa { color: #BA2121 } /* Literal.String.Affix */ .highlight-ipynb .sb { color: #BA2121 } /* Literal.String.Backtick */ .highlight-ipynb .sc { color: #BA2121 } /* Literal.String.Char */ .highlight-ipynb .dl { color: #BA2121 } /* Literal.String.Delimiter */ .highlight-ipynb .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */ .highlight-ipynb .s2 { color: #BA2121 } /* Literal.String.Double */ .highlight-ipynb .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */ .highlight-ipynb .sh { color: #BA2121 } /* Literal.String.Heredoc */ .highlight-ipynb .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */ .highlight-ipynb .sx { color: #008000 } /* Literal.String.Other */ .highlight-ipynb .sr { color: #A45A77 } /* Literal.String.Regex */ .highlight-ipynb .s1 { color: #BA2121 } /* Literal.String.Single */ .highlight-ipynb .ss { color: #19177C } /* Literal.String.Symbol */ .highlight-ipynb .bp { color: #008000 } /* Name.Builtin.Pseudo */ .highlight-ipynb .fm { color: #0000FF } /* Name.Function.Magic */ .highlight-ipynb .vc { color: #19177C } /* Name.Variable.Class */ .highlight-ipynb .vg { color: #19177C } /* Name.Variable.Global */ .highlight-ipynb .vi { color: #19177C } /* Name.Variable.Instance */ .highlight-ipynb .vm { color: #19177C } /* Name.Variable.Magic */ .highlight-ipynb .il { color: #666666 } /* Literal.Number.Integer.Long */ .rendered_html a{text-decoration:inherit !important}.rendered_html :link{text-decoration:inherit !important}.rendered_html :visited{text-decoration:inherit !important}pre code{background-color:inherit !important}.highlight{color:#000000}.highlight code{color:#000000}.highlight .n{color:#333333}.highlight .p{color:#000000}.text_cell .prompt{display:none !important}div.input_prompt{padding:0.2em 0.4em}div.output_prompt{padding:0.4em}.text_cell{margin:0 !important;padding:0 !important;border:none !important}.text_cell_render{margin:0 !important;padding:0 !important;border:none !important}.rendered_html *+p{margin-top:inherit !important}.anchor-link{display:none !important}.code_cell{margin:0 !important;padding:5px 0 !important;border:none !important}.celltoolbar{border:thin solid #CFCFCF;border-bottom:none;background:#EEE;border-radius:2px 2px 0px 0px;width:100%;height:29px;padding-right:4px;box-orient:horizontal;box-align:stretch;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;box-pack:end;-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;display:-webkit-flex}.celltoolbar .tags_button_container{display:-webkit-box;display:-ms-flexbox;display:flex}.celltoolbar .tags_button_container .tag-container{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;overflow:hidden;position:relative}.celltoolbar .tags_button_container .tag-container .cell-tag{background-color:#fff;white-space:nowrap;margin:3px 4px;padding:0 4px;border-radius:1px;border:1px solid #ccc;-webkit-box-shadow:none;box-shadow:none;width:inherit;font-size:13px;font-family:\"Helvetica Neue\", Helvetica, Arial, sans-serif;height:22px;line-height:22px;display:inline-block}div.input_area>div.highlight{margin:0.25em 0.4em !important}.code_cell pre{font-size:12px !important}.output_html table.dataframe{font-family:Arial, sans-serif;font-size:13px;line-height:20px}.output_html table.dataframe th,td{padding:4px;text-align:left}.bk-plot-wrapper tbody tr{background:none !important}.bk-plot-wrapper tbody tr:hover{background:none !important} /*# sourceMappingURL=jupyter-fixes.min.css.map */ MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], [\"\\\\(\",\"\\\\)\"] ], displayMath: [ ['$$','$$'], [\"\\\\[\",\"\\\\]\"] ], processEscapes: true, processEnvironments: true }, // Center justify equations in code and markdown cells. Elsewhere // we use CSS to left justify single line equations in code cells. displayAlign: 'center', \"HTML-CSS\": { styles: {'.MathJax_Display': {\"margin\": 0}}, linebreaks: { automatic: true } } }); Initialize a GameDataset and some sample operations \u00b6 A GameDatset instance can contain tracking and events data in a TrackingFrame and EventsFrame respectively. In [2]: import sys sys . path . insert ( 1 , '../../' ) from codeball import GameDataset , Zones metadata_file = ( r \"../../codeball/tests/files/metadata.xml\" ) tracking_file = ( r \"../../codeball/tests/files/tracking.txt\" ) events_file = ( r \"../../codeball/tests/files/events.json\" ) game_dataset = GameDataset ( tracking_metadata_file = metadata_file , tracking_data_file = tracking_file , events_metadata_file = metadata_file , events_data_file = events_file , ) print ( type ( game_dataset . tracking )) print ( type ( game_dataset . events )) <class 'codeball.codeball_frames.TrackingFrame'> <class 'codeball.codeball_frames.EventsFrame'> Tracking \u00b6 GameDataset.tracking holds a TrackingFrame with all the tacking data of the game. In [7]: game_dataset . tracking . head () Out[7]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } period_id timestamp ball_state ball_owning_team_id ball_x ball_y P3578_x P3578_y P3568_x P3568_y ... P3590_x P3590_y P3591_x P3591_y P3592_x P3592_y P3593_x P3593_y P3594_x P3594_y 0 1 0.04 None None NaN NaN 0.84722 0.52855 0.65268 0.24792 ... 0.41381 0.52790 0.41787 0.48086 0.41215 0.36689 0.47050 0.73219 0.48864 0.36357 1 1 0.08 None None NaN NaN 0.84722 0.52855 0.65231 0.24513 ... 0.41375 0.52780 0.41719 0.47864 0.41132 0.36169 0.47040 0.73204 0.48834 0.36362 2 1 0.12 None None NaN NaN 0.84722 0.52855 0.65197 0.24387 ... 0.41371 0.52906 0.41697 0.47824 0.41131 0.36072 0.47075 0.73229 0.48814 0.36372 3 1 0.16 None None NaN NaN 0.84722 0.52855 0.65166 0.24288 ... 0.41370 0.53056 0.41685 0.47815 0.41117 0.35930 0.47118 0.73266 0.48793 0.36278 4 1 0.20 None None NaN NaN 0.84722 0.52855 0.65141 0.24251 ... 0.41369 0.53151 0.41669 0.47749 0.41120 0.35910 0.47163 0.73287 0.48784 0.36240 5 rows \u00d7 50 columns If you want to filter the TrackingFrame, you can use it's methods (on top of all standard DataFrame methods). For example to get a TrackingFrame only with the data of team with team_id FIFATMA you can do: In [8]: game_dataset . tracking . team ( 'FIFATMA' ) . head () Out[8]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } P3578_x P3578_y P3568_x P3568_y P3569_x P3569_y P3570_x P3570_y P3571_x P3571_y ... P3573_x P3573_y P3574_x P3574_y P3575_x P3575_y P3576_x P3576_y P3577_x P3577_y 0 0.84722 0.52855 0.65268 0.24792 0.66525 0.46562 0.68103 0.59083 0.62405 0.80669 ... 0.60798 0.45155 0.50212 0.45314 0.62012 0.60667 0.51839 0.77140 0.50555 0.50863 1 0.84722 0.52855 0.65231 0.24513 0.66482 0.46548 0.68095 0.59054 0.62371 0.80594 ... 0.60783 0.44918 0.50158 0.45544 0.61987 0.60474 0.51801 0.77130 0.50545 0.50532 2 0.84722 0.52855 0.65197 0.24387 0.66467 0.46537 0.68078 0.59035 0.62354 0.80601 ... 0.60779 0.44866 0.50126 0.45662 0.61980 0.60422 0.51787 0.77080 0.50552 0.50524 3 0.84722 0.52855 0.65166 0.24288 0.66460 0.46488 0.68063 0.58987 0.62318 0.80604 ... 0.60762 0.44898 0.50119 0.45815 0.61976 0.60397 0.51773 0.77031 0.50563 0.50524 4 0.84722 0.52855 0.65141 0.24251 0.66452 0.46469 0.68052 0.58934 0.62286 0.80626 ... 0.60748 0.44888 0.50114 0.45986 0.61967 0.60417 0.51759 0.77008 0.50576 0.50531 5 rows \u00d7 22 columns Final example, let's say you want to get the x coordiante data, only for the field players (excluding goalkeeper) for team_id FIFATMA , you can get that by doing: In [6]: game_dataset . tracking . team ( 'FIFATMA' ) . players ( 'field' ) . dimension ( 'x' ) . head () Out[6]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } P3568_x P3569_x P3570_x P3571_x P3572_x P3573_x P3574_x P3575_x P3576_x P3577_x 0 0.65268 0.66525 0.68103 0.62405 0.50533 0.60798 0.50212 0.62012 0.51839 0.50555 1 0.65231 0.66482 0.68095 0.62371 0.50461 0.60783 0.50158 0.61987 0.51801 0.50545 2 0.65197 0.66467 0.68078 0.62354 0.50430 0.60779 0.50126 0.61980 0.51787 0.50552 3 0.65166 0.66460 0.68063 0.62318 0.50394 0.60762 0.50119 0.61976 0.51773 0.50563 4 0.65141 0.66452 0.68052 0.62286 0.50371 0.60748 0.50114 0.61967 0.51759 0.50576 Events \u00b6 Similarly, GameDataset.events holds a TrackingFrame with all the tacking data of the game, and if you want to filter it, you can do so using it's methods. For example to get all event that go into the opponent box you can do game_dataset.events.into(Zones.OPPONENT_BOX) , or if you want to get all the passes you can do: In [15]: game_dataset . events . type ( 'PASS' ) . head () Out[15]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } event_id event_type result success period_id timestamp end_timestamp ball_state ball_owning_team team_id player_id coordinates_x coordinates_y end_coordinates_x end_coordinates_y receiver_player_id inverted 1 None PASS COMPLETE True 1 14.44 15.08 alive FIFATMA FIFATMA P3577 0.49875 0.51275 0.50136 0.51295 P3574 True 3 None PASS COMPLETE True 1 15.36 17.04 alive FIFATMA FIFATMA P3574 0.50300 0.51500 0.36627 0.36551 P3575 True 5 None PASS COMPLETE True 1 18.60 20.28 alive FIFATMA FIFATMA P3575 0.33014 0.40293 0.19398 0.60179 P3569 True 7 None PASS COMPLETE True 1 21.20 23.20 alive FIFATMA FIFATMA P3569 0.19071 0.57078 0.20094 0.18478 P3570 True 9 None PASS COMPLETE True 1 23.92 25.12 alive FIFATMA FIFATMA P3570 0.20244 0.18002 0.31899 0.01941 P3571 True Since in this game tracking and event daa come from the same provider, GameDataset.metadata for this case is the same as GameDataset.tracking.metadata and GameDataset.events.metadata. There ou can access metadata about the data like frame rate, field dimensions, teams and players details, etc. Like: In [23]: game_dataset . metadata . teams [ 0 ] . players [ 5 ] . name Out[23]: 'Player 5' In [24]: game_dataset . metadata . frame_rate Out[24]: 25 In [25]: game_dataset . metadata . score Out[25]: Score(home=0, away=2) For more details about metadata attributes and methods see kloppy's documentation .","title":"GameDataset"},{"location":"examples/game_dataset/#initialize-a-gamedataset-and-some-sample-operations","text":"A GameDatset instance can contain tracking and events data in a TrackingFrame and EventsFrame respectively. In [2]: import sys sys . path . insert ( 1 , '../../' ) from codeball import GameDataset , Zones metadata_file = ( r \"../../codeball/tests/files/metadata.xml\" ) tracking_file = ( r \"../../codeball/tests/files/tracking.txt\" ) events_file = ( r \"../../codeball/tests/files/events.json\" ) game_dataset = GameDataset ( tracking_metadata_file = metadata_file , tracking_data_file = tracking_file , events_metadata_file = metadata_file , events_data_file = events_file , ) print ( type ( game_dataset . tracking )) print ( type ( game_dataset . events )) <class 'codeball.codeball_frames.TrackingFrame'> <class 'codeball.codeball_frames.EventsFrame'>","title":"Initialize a GameDataset and some sample operations"},{"location":"examples/game_dataset/#tracking","text":"GameDataset.tracking holds a TrackingFrame with all the tacking data of the game. In [7]: game_dataset . tracking . head () Out[7]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } period_id timestamp ball_state ball_owning_team_id ball_x ball_y P3578_x P3578_y P3568_x P3568_y ... P3590_x P3590_y P3591_x P3591_y P3592_x P3592_y P3593_x P3593_y P3594_x P3594_y 0 1 0.04 None None NaN NaN 0.84722 0.52855 0.65268 0.24792 ... 0.41381 0.52790 0.41787 0.48086 0.41215 0.36689 0.47050 0.73219 0.48864 0.36357 1 1 0.08 None None NaN NaN 0.84722 0.52855 0.65231 0.24513 ... 0.41375 0.52780 0.41719 0.47864 0.41132 0.36169 0.47040 0.73204 0.48834 0.36362 2 1 0.12 None None NaN NaN 0.84722 0.52855 0.65197 0.24387 ... 0.41371 0.52906 0.41697 0.47824 0.41131 0.36072 0.47075 0.73229 0.48814 0.36372 3 1 0.16 None None NaN NaN 0.84722 0.52855 0.65166 0.24288 ... 0.41370 0.53056 0.41685 0.47815 0.41117 0.35930 0.47118 0.73266 0.48793 0.36278 4 1 0.20 None None NaN NaN 0.84722 0.52855 0.65141 0.24251 ... 0.41369 0.53151 0.41669 0.47749 0.41120 0.35910 0.47163 0.73287 0.48784 0.36240 5 rows \u00d7 50 columns If you want to filter the TrackingFrame, you can use it's methods (on top of all standard DataFrame methods). For example to get a TrackingFrame only with the data of team with team_id FIFATMA you can do: In [8]: game_dataset . tracking . team ( 'FIFATMA' ) . head () Out[8]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } P3578_x P3578_y P3568_x P3568_y P3569_x P3569_y P3570_x P3570_y P3571_x P3571_y ... P3573_x P3573_y P3574_x P3574_y P3575_x P3575_y P3576_x P3576_y P3577_x P3577_y 0 0.84722 0.52855 0.65268 0.24792 0.66525 0.46562 0.68103 0.59083 0.62405 0.80669 ... 0.60798 0.45155 0.50212 0.45314 0.62012 0.60667 0.51839 0.77140 0.50555 0.50863 1 0.84722 0.52855 0.65231 0.24513 0.66482 0.46548 0.68095 0.59054 0.62371 0.80594 ... 0.60783 0.44918 0.50158 0.45544 0.61987 0.60474 0.51801 0.77130 0.50545 0.50532 2 0.84722 0.52855 0.65197 0.24387 0.66467 0.46537 0.68078 0.59035 0.62354 0.80601 ... 0.60779 0.44866 0.50126 0.45662 0.61980 0.60422 0.51787 0.77080 0.50552 0.50524 3 0.84722 0.52855 0.65166 0.24288 0.66460 0.46488 0.68063 0.58987 0.62318 0.80604 ... 0.60762 0.44898 0.50119 0.45815 0.61976 0.60397 0.51773 0.77031 0.50563 0.50524 4 0.84722 0.52855 0.65141 0.24251 0.66452 0.46469 0.68052 0.58934 0.62286 0.80626 ... 0.60748 0.44888 0.50114 0.45986 0.61967 0.60417 0.51759 0.77008 0.50576 0.50531 5 rows \u00d7 22 columns Final example, let's say you want to get the x coordiante data, only for the field players (excluding goalkeeper) for team_id FIFATMA , you can get that by doing: In [6]: game_dataset . tracking . team ( 'FIFATMA' ) . players ( 'field' ) . dimension ( 'x' ) . head () Out[6]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } P3568_x P3569_x P3570_x P3571_x P3572_x P3573_x P3574_x P3575_x P3576_x P3577_x 0 0.65268 0.66525 0.68103 0.62405 0.50533 0.60798 0.50212 0.62012 0.51839 0.50555 1 0.65231 0.66482 0.68095 0.62371 0.50461 0.60783 0.50158 0.61987 0.51801 0.50545 2 0.65197 0.66467 0.68078 0.62354 0.50430 0.60779 0.50126 0.61980 0.51787 0.50552 3 0.65166 0.66460 0.68063 0.62318 0.50394 0.60762 0.50119 0.61976 0.51773 0.50563 4 0.65141 0.66452 0.68052 0.62286 0.50371 0.60748 0.50114 0.61967 0.51759 0.50576","title":"Tracking"},{"location":"examples/game_dataset/#events","text":"Similarly, GameDataset.events holds a TrackingFrame with all the tacking data of the game, and if you want to filter it, you can do so using it's methods. For example to get all event that go into the opponent box you can do game_dataset.events.into(Zones.OPPONENT_BOX) , or if you want to get all the passes you can do: In [15]: game_dataset . events . type ( 'PASS' ) . head () Out[15]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } event_id event_type result success period_id timestamp end_timestamp ball_state ball_owning_team team_id player_id coordinates_x coordinates_y end_coordinates_x end_coordinates_y receiver_player_id inverted 1 None PASS COMPLETE True 1 14.44 15.08 alive FIFATMA FIFATMA P3577 0.49875 0.51275 0.50136 0.51295 P3574 True 3 None PASS COMPLETE True 1 15.36 17.04 alive FIFATMA FIFATMA P3574 0.50300 0.51500 0.36627 0.36551 P3575 True 5 None PASS COMPLETE True 1 18.60 20.28 alive FIFATMA FIFATMA P3575 0.33014 0.40293 0.19398 0.60179 P3569 True 7 None PASS COMPLETE True 1 21.20 23.20 alive FIFATMA FIFATMA P3569 0.19071 0.57078 0.20094 0.18478 P3570 True 9 None PASS COMPLETE True 1 23.92 25.12 alive FIFATMA FIFATMA P3570 0.20244 0.18002 0.31899 0.01941 P3571 True Since in this game tracking and event daa come from the same provider, GameDataset.metadata for this case is the same as GameDataset.tracking.metadata and GameDataset.events.metadata. There ou can access metadata about the data like frame rate, field dimensions, teams and players details, etc. Like: In [23]: game_dataset . metadata . teams [ 0 ] . players [ 5 ] . name Out[23]: 'Player 5' In [24]: game_dataset . metadata . frame_rate Out[24]: 25 In [25]: game_dataset . metadata . score Out[25]: Score(home=0, away=2) For more details about metadata attributes and methods see kloppy's documentation .","title":"Events"},{"location":"examples/run_patterns/","text":"/*! * * IPython notebook * */ /* CSS font colors for translated ANSI escape sequences */ /* The color values are a mix of http://www.xcolors.net/dl/baskerville-ivorylight and http://www.xcolors.net/dl/euphrasia */ .ansi-black-fg { color: #3E424D; } .ansi-black-bg { background-color: #3E424D; } .ansi-black-intense-fg { color: #282C36; } .ansi-black-intense-bg { background-color: #282C36; } .ansi-red-fg { color: #E75C58; } .ansi-red-bg { background-color: #E75C58; } .ansi-red-intense-fg { color: #B22B31; } .ansi-red-intense-bg { background-color: #B22B31; } .ansi-green-fg { color: #00A250; } .ansi-green-bg { background-color: #00A250; } .ansi-green-intense-fg { color: #007427; } .ansi-green-intense-bg { background-color: #007427; } .ansi-yellow-fg { color: #DDB62B; } .ansi-yellow-bg { background-color: #DDB62B; } .ansi-yellow-intense-fg { color: #B27D12; } .ansi-yellow-intense-bg { background-color: #B27D12; } .ansi-blue-fg { color: #208FFB; } .ansi-blue-bg { background-color: #208FFB; } .ansi-blue-intense-fg { color: #0065CA; } .ansi-blue-intense-bg { background-color: #0065CA; } .ansi-magenta-fg { color: #D160C4; } .ansi-magenta-bg { background-color: #D160C4; } .ansi-magenta-intense-fg { color: #A03196; } .ansi-magenta-intense-bg { background-color: #A03196; } .ansi-cyan-fg { color: #60C6C8; } .ansi-cyan-bg { background-color: #60C6C8; } .ansi-cyan-intense-fg { color: #258F8F; } .ansi-cyan-intense-bg { background-color: #258F8F; } .ansi-white-fg { color: #C5C1B4; } .ansi-white-bg { background-color: #C5C1B4; } .ansi-white-intense-fg { color: #A1A6B2; } .ansi-white-intense-bg { background-color: #A1A6B2; } .ansi-default-inverse-fg { color: #FFFFFF; } .ansi-default-inverse-bg { background-color: #000000; } .ansi-bold { font-weight: bold; } .ansi-underline { text-decoration: underline; } /* The following styles are deprecated an will be removed in a future version */ .ansibold { font-weight: bold; } .ansi-inverse { outline: 0.5px dotted; } /* use dark versions for foreground, to improve visibility */ .ansiblack { color: black; } .ansired { color: darkred; } .ansigreen { color: darkgreen; } .ansiyellow { color: #c4a000; } .ansiblue { color: darkblue; } .ansipurple { color: darkviolet; } .ansicyan { color: steelblue; } .ansigray { color: gray; } /* and light for background, for the same reason */ .ansibgblack { background-color: black; } .ansibgred { background-color: red; } .ansibggreen { background-color: green; } .ansibgyellow { background-color: yellow; } .ansibgblue { background-color: blue; } .ansibgpurple { background-color: magenta; } .ansibgcyan { background-color: cyan; } .ansibggray { background-color: gray; } div.cell { /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; border-radius: 2px; box-sizing: border-box; -moz-box-sizing: border-box; -webkit-box-sizing: border-box; border-width: 1px; border-style: solid; border-color: transparent; width: 100%; padding: 5px; /* This acts as a spacer between cells, that is outside the border */ margin: 0px; outline: none; position: relative; overflow: visible; } div.cell:before { position: absolute; display: block; top: -1px; left: -1px; width: 5px; height: calc(100% + 2px); content: ''; background: transparent; } div.cell.jupyter-soft-selected { border-left-color: #E3F2FD; border-left-width: 1px; padding-left: 5px; border-right-color: #E3F2FD; border-right-width: 1px; background: #E3F2FD; } @media print { div.cell.jupyter-soft-selected { border-color: transparent; } } div.cell.selected, div.cell.selected.jupyter-soft-selected { border-color: #ababab; } div.cell.selected:before, div.cell.selected.jupyter-soft-selected:before { position: absolute; display: block; top: -1px; left: -1px; width: 5px; height: calc(100% + 2px); content: ''; background: #42A5F5; } @media print { div.cell.selected, div.cell.selected.jupyter-soft-selected { border-color: transparent; } } .edit_mode div.cell.selected { border-color: #66BB6A; } .edit_mode div.cell.selected:before { position: absolute; display: block; top: -1px; left: -1px; width: 5px; height: calc(100% + 2px); content: ''; background: #66BB6A; } @media print { .edit_mode div.cell.selected { border-color: transparent; } } .prompt { /* This needs to be wide enough for 3 digit prompt numbers: In[100]: */ min-width: 14ex; /* This padding is tuned to match the padding on the CodeMirror editor. */ padding: 0.4em; margin: 0px; font-family: monospace; text-align: right; /* This has to match that of the the CodeMirror class line-height below */ line-height: 1.21429em; /* Don't highlight prompt number selection */ -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; /* Use default cursor */ cursor: default; } @media (max-width: 540px) { .prompt { text-align: left; } } div.inner_cell { min-width: 0; /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; /* Old browsers */ -webkit-box-flex: 1; -moz-box-flex: 1; box-flex: 1; /* Modern browsers */ flex: 1; } /* input_area and input_prompt must match in top border and margin for alignment */ div.input_area { border: 1px solid #cfcfcf; border-radius: 2px; background: #f7f7f7; line-height: 1.21429em; } /* This is needed so that empty prompt areas can collapse to zero height when there is no content in the output_subarea and the prompt. The main purpose of this is to make sure that empty JavaScript output_subareas have no height. */ div.prompt:empty { padding-top: 0; padding-bottom: 0; } div.unrecognized_cell { padding: 5px 5px 5px 0px; /* Old browsers */ display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: horizontal; -moz-box-align: stretch; display: box; box-orient: horizontal; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: row; align-items: stretch; } div.unrecognized_cell .inner_cell { border-radius: 2px; padding: 5px; font-weight: bold; color: red; border: 1px solid #cfcfcf; background: #eaeaea; } div.unrecognized_cell .inner_cell a { color: inherit; text-decoration: none; } div.unrecognized_cell .inner_cell a:hover { color: inherit; text-decoration: none; } @media (max-width: 540px) { div.unrecognized_cell > div.prompt { display: none; } } div.code_cell { /* avoid page breaking on code cells when printing */ } @media print { div.code_cell { page-break-inside: avoid; } } /* any special styling for code cells that are currently running goes here */ div.input { page-break-inside: avoid; /* Old browsers */ display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: horizontal; -moz-box-align: stretch; display: box; box-orient: horizontal; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: row; align-items: stretch; } @media (max-width: 540px) { div.input { /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; } } /* input_area and input_prompt must match in top border and margin for alignment */ div.input_prompt { color: #303F9F; border-top: 1px solid transparent; } div.input_area > div.highlight { margin: 0.4em; border: none; padding: 0px; background-color: transparent; } div.input_area > div.highlight > pre { margin: 0px; border: none; padding: 0px; background-color: transparent; } /* The following gets added to the <head> if it is detected that the user has a * monospace font with inconsistent normal/bold/italic height. See * notebookmain.js. Such fonts will have keywords vertically offset with * respect to the rest of the text. The user should select a better font. * See: https://github.com/ipython/ipython/issues/1503 * * .CodeMirror span { * vertical-align: bottom; * } */ .CodeMirror { line-height: 1.21429em; /* Changed from 1em to our global default */ font-size: 14px; height: auto; /* Changed to auto to autogrow */ background: none; /* Changed from white to allow our bg to show through */ } .CodeMirror-scroll { /* The CodeMirror docs are a bit fuzzy on if overflow-y should be hidden or visible.*/ /* We have found that if it is visible, vertical scrollbars appear with font size changes.*/ overflow-y: hidden; overflow-x: auto; } .CodeMirror-lines { /* In CM2, this used to be 0.4em, but in CM3 it went to 4px. We need the em value because */ /* we have set a different line-height and want this to scale with that. */ /* Note that this should set vertical padding only, since CodeMirror assumes that horizontal padding will be set on CodeMirror pre */ padding: 0.4em 0; } .CodeMirror-linenumber { padding: 0 8px 0 4px; } .CodeMirror-gutters { border-bottom-left-radius: 2px; border-top-left-radius: 2px; } .CodeMirror pre { /* In CM3 this went to 4px from 0 in CM2. This sets horizontal padding only, use .CodeMirror-lines for vertical */ padding: 0 0.4em; border: 0; border-radius: 0; } .CodeMirror-cursor { border-left: 1.4px solid black; } @media screen and (min-width: 2138px) and (max-width: 4319px) { .CodeMirror-cursor { border-left: 2px solid black; } } @media screen and (min-width: 4320px) { .CodeMirror-cursor { border-left: 4px solid black; } } /* Original style from softwaremaniacs.org (c) Ivan Sagalaev <Maniac@SoftwareManiacs.Org> Adapted from GitHub theme */ .highlight-base { color: #000; } .highlight-variable { color: #000; } .highlight-variable-2 { color: #1a1a1a; } .highlight-variable-3 { color: #333333; } .highlight-string { color: #BA2121; } .highlight-comment { color: #408080; font-style: italic; } .highlight-number { color: #080; } .highlight-atom { color: #88F; } .highlight-keyword { color: #008000; font-weight: bold; } .highlight-builtin { color: #008000; } .highlight-error { color: #f00; } .highlight-operator { color: #AA22FF; font-weight: bold; } .highlight-meta { color: #AA22FF; } /* previously not defined, copying from default codemirror */ .highlight-def { color: #00f; } .highlight-string-2 { color: #f50; } .highlight-qualifier { color: #555; } .highlight-bracket { color: #997; } .highlight-tag { color: #170; } .highlight-attribute { color: #00c; } .highlight-header { color: blue; } .highlight-quote { color: #090; } .highlight-link { color: #00c; } /* apply the same style to codemirror */ .cm-s-ipython span.cm-keyword { color: #008000; font-weight: bold; } .cm-s-ipython span.cm-atom { color: #88F; } .cm-s-ipython span.cm-number { color: #080; } .cm-s-ipython span.cm-def { color: #00f; } .cm-s-ipython span.cm-variable { color: #000; } .cm-s-ipython span.cm-operator { color: #AA22FF; font-weight: bold; } .cm-s-ipython span.cm-variable-2 { color: #1a1a1a; } .cm-s-ipython span.cm-variable-3 { color: #333333; } .cm-s-ipython span.cm-comment { color: #408080; font-style: italic; } .cm-s-ipython span.cm-string { color: #BA2121; } .cm-s-ipython span.cm-string-2 { color: #f50; } .cm-s-ipython span.cm-meta { color: #AA22FF; } .cm-s-ipython span.cm-qualifier { color: #555; } .cm-s-ipython span.cm-builtin { color: #008000; } .cm-s-ipython span.cm-bracket { color: #997; } .cm-s-ipython span.cm-tag { color: #170; } .cm-s-ipython span.cm-attribute { color: #00c; } .cm-s-ipython span.cm-header { color: blue; } .cm-s-ipython span.cm-quote { color: #090; } .cm-s-ipython span.cm-link { color: #00c; } .cm-s-ipython span.cm-error { color: #f00; } .cm-s-ipython span.cm-tab { background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAMCAYAAAAkuj5RAAAAAXNSR0IArs4c6QAAAGFJREFUSMft1LsRQFAQheHPowAKoACx3IgEKtaEHujDjORSgWTH/ZOdnZOcM/sgk/kFFWY0qV8foQwS4MKBCS3qR6ixBJvElOobYAtivseIE120FaowJPN75GMu8j/LfMwNjh4HUpwg4LUAAAAASUVORK5CYII=); background-position: right; background-repeat: no-repeat; } div.output_wrapper { /* this position must be relative to enable descendents to be absolute within it */ position: relative; /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; z-index: 1; } /* class for the output area when it should be height-limited */ div.output_scroll { /* ideally, this would be max-height, but FF barfs all over that */ height: 24em; /* FF needs this *and the wrapper* to specify full width, or it will shrinkwrap */ width: 100%; overflow: auto; border-radius: 2px; -webkit-box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.8); box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.8); display: block; } /* output div while it is collapsed */ div.output_collapsed { margin: 0px; padding: 0px; /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; } div.out_prompt_overlay { height: 100%; padding: 0px 0.4em; position: absolute; border-radius: 2px; } div.out_prompt_overlay:hover { /* use inner shadow to get border that is computed the same on WebKit/FF */ -webkit-box-shadow: inset 0 0 1px #000; box-shadow: inset 0 0 1px #000; background: rgba(240, 240, 240, 0.5); } div.output_prompt { color: #D84315; } /* This class is the outer container of all output sections. */ div.output_area { padding: 0px; page-break-inside: avoid; /* Old browsers */ display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: horizontal; -moz-box-align: stretch; display: box; box-orient: horizontal; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: row; align-items: stretch; } div.output_area .MathJax_Display { text-align: left !important; } div.output_area div.output_area div.output_area img, div.output_area svg { max-width: 100%; height: auto; } div.output_area img.unconfined, div.output_area svg.unconfined { max-width: none; } div.output_area .mglyph > img { max-width: none; } /* This is needed to protect the pre formating from global settings such as that of bootstrap */ .output { /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; } @media (max-width: 540px) { div.output_area { /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; } } div.output_area pre { margin: 0; padding: 1px 0 1px 0; border: 0; vertical-align: baseline; color: black; background-color: transparent; border-radius: 0; } /* This class is for the output subarea inside the output_area and after the prompt div. */ div.output_subarea { overflow-x: auto; padding: 0.4em; /* Old browsers */ -webkit-box-flex: 1; -moz-box-flex: 1; box-flex: 1; /* Modern browsers */ flex: 1; max-width: calc(100% - 14ex); } div.output_scroll div.output_subarea { overflow-x: visible; } /* The rest of the output_* classes are for special styling of the different output types */ /* all text output has this class: */ div.output_text { text-align: left; color: #000; /* This has to match that of the the CodeMirror class line-height below */ line-height: 1.21429em; } /* stdout/stderr are 'text' as well as 'stream', but execute_result/error are *not* streams */ div.output_stderr { background: #fdd; /* very light red background for stderr */ } div.output_latex { text-align: left; } /* Empty output_javascript divs should have no height */ div.output_javascript:empty { padding: 0; } .js-error { color: darkred; } /* raw_input styles */ div.raw_input_container { line-height: 1.21429em; padding-top: 5px; } pre.raw_input_prompt { /* nothing needed here. */ } input.raw_input { font-family: monospace; font-size: inherit; color: inherit; width: auto; /* make sure input baseline aligns with prompt */ vertical-align: baseline; /* padding + margin = 0.5em between prompt and cursor */ padding: 0em 0.25em; margin: 0em 0.25em; } input.raw_input:focus { box-shadow: none; } p.p-space { margin-bottom: 10px; } div.output_unrecognized { padding: 5px; font-weight: bold; color: red; } div.output_unrecognized a { color: inherit; text-decoration: none; } div.output_unrecognized a:hover { color: inherit; text-decoration: none; } .rendered_html { color: #000; /* any extras will just be numbers: */ } .rendered_html :link { text-decoration: underline; } .rendered_html :visited { text-decoration: underline; } .rendered_html h1:first-child { margin-top: 0.538em; } .rendered_html h2:first-child { margin-top: 0.636em; } .rendered_html h3:first-child { margin-top: 0.777em; } .rendered_html h4:first-child { margin-top: 1em; } .rendered_html h5:first-child { margin-top: 1em; } .rendered_html h6:first-child { margin-top: 1em; } .rendered_html ul:not(.list-inline), .rendered_html ol:not(.list-inline) { padding-left: 2em; } .rendered_html * + ul { margin-top: 1em; } .rendered_html * + ol { margin-top: 1em; } .rendered_html pre, .rendered_html tr, .rendered_html th, .rendered_html tbody tr:nth-child(odd) { background: #f5f5f5; } .rendered_html tbody tr:hover { background: rgba(66, 165, 245, 0.2); } .rendered_html * + table { margin-top: 1em; } .rendered_html * + p { margin-top: 1em; } .rendered_html * + img { margin-top: 1em; } .rendered_html img, .rendered_html img.unconfined, .rendered_html * + .alert { margin-top: 1em; } [dir=\"rtl\"] div.text_cell { /* Old browsers */ display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: horizontal; -moz-box-align: stretch; display: box; box-orient: horizontal; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: row; align-items: stretch; } @media (max-width: 540px) { div.text_cell > div.prompt { display: none; } } div.text_cell_render { /*font-family: \"Helvetica Neue\", Arial, Helvetica, Geneva, sans-serif;*/ outline: none; resize: none; width: inherit; border-style: none; padding: 0.5em 0.5em 0.5em 0.4em; color: #000; box-sizing: border-box; -moz-box-sizing: border-box; -webkit-box-sizing: border-box; } a.anchor-link:link { text-decoration: none; padding: 0px 20px; visibility: hidden; } h1:hover .anchor-link, h2:hover .anchor-link, h3:hover .anchor-link, h4:hover .anchor-link, h5:hover .anchor-link, h6:hover .anchor-link { visibility: visible; } .text_cell.rendered .input_area { display: none; } .text_cell.rendered .text_cell.rendered .rendered_html tr, .text_cell.rendered .rendered_html th, .text_cell.rendered .text_cell.unrendered .text_cell_render { display: none; } .text_cell .dropzone .input_area { border: 2px dashed #bababa; margin: -1px; } .cm-header-1, .cm-header-2, .cm-header-3, .cm-header-4, .cm-header-5, .cm-header-6 { font-weight: bold; font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif; } .cm-header-1 { font-size: 185.7%; } .cm-header-2 { font-size: 157.1%; } .cm-header-3 { font-size: 128.6%; } .cm-header-4 { font-size: 110%; } .cm-header-5 { font-size: 100%; font-style: italic; } .cm-header-6 { font-size: 100%; font-style: italic; } pre { line-height: 125%; } td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; } span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; } td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; } span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; } .highlight-ipynb .hll { background-color: #ffffcc } .highlight-ipynb { background: #f8f8f8; } .highlight-ipynb .c { color: #3D7B7B; font-style: italic } /* Comment */ .highlight-ipynb .err { border: 1px solid #FF0000 } /* Error */ .highlight-ipynb .k { color: #008000; font-weight: bold } /* Keyword */ .highlight-ipynb .o { color: #666666 } /* Operator */ .highlight-ipynb .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */ .highlight-ipynb .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */ .highlight-ipynb .cp { color: #9C6500 } /* Comment.Preproc */ .highlight-ipynb .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */ .highlight-ipynb .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */ .highlight-ipynb .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */ .highlight-ipynb .gd { color: #A00000 } /* Generic.Deleted */ .highlight-ipynb .ge { font-style: italic } /* Generic.Emph */ .highlight-ipynb .gr { color: #E40000 } /* Generic.Error */ .highlight-ipynb .gh { color: #000080; font-weight: bold } /* Generic.Heading */ .highlight-ipynb .gi { color: #008400 } /* Generic.Inserted */ .highlight-ipynb .go { color: #717171 } /* Generic.Output */ .highlight-ipynb .gp { color: #000080; font-weight: bold } /* Generic.Prompt */ .highlight-ipynb .gs { font-weight: bold } /* Generic.Strong */ .highlight-ipynb .gu { color: #800080; font-weight: bold } /* Generic.Subheading */ .highlight-ipynb .gt { color: #0044DD } /* Generic.Traceback */ .highlight-ipynb .kc { color: #008000; font-weight: bold } /* Keyword.Constant */ .highlight-ipynb .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */ .highlight-ipynb .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */ .highlight-ipynb .kp { color: #008000 } /* Keyword.Pseudo */ .highlight-ipynb .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */ .highlight-ipynb .kt { color: #B00040 } /* Keyword.Type */ .highlight-ipynb .m { color: #666666 } /* Literal.Number */ .highlight-ipynb .s { color: #BA2121 } /* Literal.String */ .highlight-ipynb .na { color: #687822 } /* Name.Attribute */ .highlight-ipynb .nb { color: #008000 } /* Name.Builtin */ .highlight-ipynb .nc { color: #0000FF; font-weight: bold } /* Name.Class */ .highlight-ipynb .no { color: #880000 } /* Name.Constant */ .highlight-ipynb .nd { color: #AA22FF } /* Name.Decorator */ .highlight-ipynb .ni { color: #717171; font-weight: bold } /* Name.Entity */ .highlight-ipynb .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */ .highlight-ipynb .nf { color: #0000FF } /* Name.Function */ .highlight-ipynb .nl { color: #767600 } /* Name.Label */ .highlight-ipynb .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */ .highlight-ipynb .nt { color: #008000; font-weight: bold } /* Name.Tag */ .highlight-ipynb .nv { color: #19177C } /* Name.Variable */ .highlight-ipynb .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */ .highlight-ipynb .w { color: #bbbbbb } /* Text.Whitespace */ .highlight-ipynb .mb { color: #666666 } /* Literal.Number.Bin */ .highlight-ipynb .mf { color: #666666 } /* Literal.Number.Float */ .highlight-ipynb .mh { color: #666666 } /* Literal.Number.Hex */ .highlight-ipynb .mi { color: #666666 } /* Literal.Number.Integer */ .highlight-ipynb .mo { color: #666666 } /* Literal.Number.Oct */ .highlight-ipynb .sa { color: #BA2121 } /* Literal.String.Affix */ .highlight-ipynb .sb { color: #BA2121 } /* Literal.String.Backtick */ .highlight-ipynb .sc { color: #BA2121 } /* Literal.String.Char */ .highlight-ipynb .dl { color: #BA2121 } /* Literal.String.Delimiter */ .highlight-ipynb .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */ .highlight-ipynb .s2 { color: #BA2121 } /* Literal.String.Double */ .highlight-ipynb .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */ .highlight-ipynb .sh { color: #BA2121 } /* Literal.String.Heredoc */ .highlight-ipynb .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */ .highlight-ipynb .sx { color: #008000 } /* Literal.String.Other */ .highlight-ipynb .sr { color: #A45A77 } /* Literal.String.Regex */ .highlight-ipynb .s1 { color: #BA2121 } /* Literal.String.Single */ .highlight-ipynb .ss { color: #19177C } /* Literal.String.Symbol */ .highlight-ipynb .bp { color: #008000 } /* Name.Builtin.Pseudo */ .highlight-ipynb .fm { color: #0000FF } /* Name.Function.Magic */ .highlight-ipynb .vc { color: #19177C } /* Name.Variable.Class */ .highlight-ipynb .vg { color: #19177C } /* Name.Variable.Global */ .highlight-ipynb .vi { color: #19177C } /* Name.Variable.Instance */ .highlight-ipynb .vm { color: #19177C } /* Name.Variable.Magic */ .highlight-ipynb .il { color: #666666 } /* Literal.Number.Integer.Long */ .rendered_html a{text-decoration:inherit !important}.rendered_html :link{text-decoration:inherit !important}.rendered_html :visited{text-decoration:inherit !important}pre code{background-color:inherit !important}.highlight{color:#000000}.highlight code{color:#000000}.highlight .n{color:#333333}.highlight .p{color:#000000}.text_cell .prompt{display:none !important}div.input_prompt{padding:0.2em 0.4em}div.output_prompt{padding:0.4em}.text_cell{margin:0 !important;padding:0 !important;border:none !important}.text_cell_render{margin:0 !important;padding:0 !important;border:none !important}.rendered_html *+p{margin-top:inherit !important}.anchor-link{display:none !important}.code_cell{margin:0 !important;padding:5px 0 !important;border:none !important}.celltoolbar{border:thin solid #CFCFCF;border-bottom:none;background:#EEE;border-radius:2px 2px 0px 0px;width:100%;height:29px;padding-right:4px;box-orient:horizontal;box-align:stretch;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;box-pack:end;-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;display:-webkit-flex}.celltoolbar .tags_button_container{display:-webkit-box;display:-ms-flexbox;display:flex}.celltoolbar .tags_button_container .tag-container{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;overflow:hidden;position:relative}.celltoolbar .tags_button_container .tag-container .cell-tag{background-color:#fff;white-space:nowrap;margin:3px 4px;padding:0 4px;border-radius:1px;border:1px solid #ccc;-webkit-box-shadow:none;box-shadow:none;width:inherit;font-size:13px;font-family:\"Helvetica Neue\", Helvetica, Arial, sans-serif;height:22px;line-height:22px;display:inline-block}div.input_area>div.highlight{margin:0.25em 0.4em !important}.code_cell pre{font-size:12px !important}.output_html table.dataframe{font-family:Arial, sans-serif;font-size:13px;line-height:20px}.output_html table.dataframe th,td{padding:4px;text-align:left}.bk-plot-wrapper tbody tr{background:none !important}.bk-plot-wrapper tbody tr:hover{background:none !important} /*# sourceMappingURL=jupyter-fixes.min.css.map */ MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], [\"\\\\(\",\"\\\\)\"] ], displayMath: [ ['$$','$$'], [\"\\\\[\",\"\\\\]\"] ], processEscapes: true, processEnvironments: true }, // Center justify equations in code and markdown cells. Elsewhere // we use CSS to left justify single line equations in code cells. displayAlign: 'center', \"HTML-CSS\": { styles: {'.MathJax_Display': {\"margin\": 0}}, linebreaks: { automatic: true } } }); Modules \u00b6 GameDataset is a class that will hold methods and data for one game. PatternsSet is a calss that willhold methods, patterns, and pattern_events data for this game. In [3]: import sys sys . path . insert ( 1 , '../../' ) from codeball import GameDataset , PatternsSet Initialize GameDataset \u00b6 Define data files. Currently reading the files in the test folder of the package. Initialize game dataset. This loads the data for each data type using Kloppy, and then stores it on game_dataset as instances of TrackinDataFrame and EventsDataFrame. Both of them are subclasses of a pandas Dataframe. Other than holding the data in a dataframe, they also have methods to work with, filter etc the data they contain. In [5]: metadata_file = ( r \"../../codeball/tests/files/metadata.xml\" ) tracking_file = ( r \"../../codeball/tests/files/tracking.txt\" ) events_file = ( r \"../../codeball/tests/files/events.json\" ) game_dataset = GameDataset ( tracking_metadata_file = metadata_file , tracking_data_file = tracking_file , events_metadata_file = metadata_file , events_data_file = events_file , ) Instantiate PatternSet and run and export patterns for play. \u00b6 The first step is to instantiate a PatternsSet instance. It takes as arugment a GameDataset instance so that all patterns can have access to the data of the game. Conceptually a pattern is an analysis that will return the moments in the game a certain thing happend, with that thing being defined in the pattern / analysis. For example, look for all passes into the box. Next step is to initialize the patterns by reading the patterns config from ../codeball/patterns/patterns_config.json. However you can specify your own pattern config by providing it as an input to initialize_patterns. Then run_patterns iterates over all the patterns in the PatternSet and runs them. Finally, save_patterns_for_play method takes all the Patterns and PatternEvents in the PatternsSet and outputs them on a json fotmat that can be imported into Metrica Play via Metrica Cloud. If you didn't clone the repo, you can get the config file here . In [8]: patterns_set = PatternsSet ( game_dataset = game_dataset ) patterns_set . initialize_patterns ( config_file = r \"../../codeball/patterns/patterns_config.json\" ) patterns_set . run_patterns () patterns_set . save_patterns_for_play ( \"output.patt\" )","title":"Run patterns"},{"location":"examples/run_patterns/#modules","text":"GameDataset is a class that will hold methods and data for one game. PatternsSet is a calss that willhold methods, patterns, and pattern_events data for this game. In [3]: import sys sys . path . insert ( 1 , '../../' ) from codeball import GameDataset , PatternsSet","title":"Modules"},{"location":"examples/run_patterns/#initialize-gamedataset","text":"Define data files. Currently reading the files in the test folder of the package. Initialize game dataset. This loads the data for each data type using Kloppy, and then stores it on game_dataset as instances of TrackinDataFrame and EventsDataFrame. Both of them are subclasses of a pandas Dataframe. Other than holding the data in a dataframe, they also have methods to work with, filter etc the data they contain. In [5]: metadata_file = ( r \"../../codeball/tests/files/metadata.xml\" ) tracking_file = ( r \"../../codeball/tests/files/tracking.txt\" ) events_file = ( r \"../../codeball/tests/files/events.json\" ) game_dataset = GameDataset ( tracking_metadata_file = metadata_file , tracking_data_file = tracking_file , events_metadata_file = metadata_file , events_data_file = events_file , )","title":"Initialize GameDataset"},{"location":"examples/run_patterns/#instantiate-patternset-and-run-and-export-patterns-for-play","text":"The first step is to instantiate a PatternsSet instance. It takes as arugment a GameDataset instance so that all patterns can have access to the data of the game. Conceptually a pattern is an analysis that will return the moments in the game a certain thing happend, with that thing being defined in the pattern / analysis. For example, look for all passes into the box. Next step is to initialize the patterns by reading the patterns config from ../codeball/patterns/patterns_config.json. However you can specify your own pattern config by providing it as an input to initialize_patterns. Then run_patterns iterates over all the patterns in the PatternSet and runs them. Finally, save_patterns_for_play method takes all the Patterns and PatternEvents in the PatternsSet and outputs them on a json fotmat that can be imported into Metrica Play via Metrica Cloud. If you didn't clone the repo, you can get the config file here . In [8]: patterns_set = PatternsSet ( game_dataset = game_dataset ) patterns_set . initialize_patterns ( config_file = r \"../../codeball/patterns/patterns_config.json\" ) patterns_set . run_patterns () patterns_set . save_patterns_for_play ( \"output.patt\" )","title":"Instantiate PatternSet and run and export patterns for play."}]}